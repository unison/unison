#!/usr/local/tools/bin/perl -w
# ss2fa -- convert ss (or p1) files to fasta
# * 2002/02/05 (Tue) 09:36 PST Reece

# usage:
# ss2fa [files ...]

use strict;
use IO::File;
use Env qw( DEBUG );
#use Getopt::Long;

my $jemappelle = $0;  $jemappelle =~ s%^.+/%%;
my $fh = new IO::File;						# global, for better speed
$DEBUG=0 unless defined $DEBUG;


unshift(@ARGV, '-') unless @ARGV;			# read from stdin unless specified

while ( @ARGV )
  {
  my $fn = shift;

  dprint(3, "# >> read1($fn)\n");
  my ($seq, $tag) = read1($fn);
  dprint(3, "# << read1($fn)\n");

  if (not defined $seq)
	{ warn("$fn: $!\n"); next; }

  if (not defined $tag)
	{ $tag = $fn; }

#  $tag =~ s%^.+/%%;
  $tag =~ s%\.p1%%;
#  $tag .= ' [' . length($seq) . ' ' . ($fn=~/\Wss\W/?'NA':'AA') . ']';

  print( join( "\n", ">$tag  # converted by $jemappelle", wrap($seq), '' ) );
  }




# read1: read one sequence from one file
# in: filename (may be - for stdin)
# out: ($seq, $tag)
# $seq is undef if err (and $! will be set)
# $tag is a heuristic attempt grok ids from the input, but MAY BE UNDEF
sub read1
  {
  my $fn = shift;
  my $seq = '';
  my $tag;
  my $tag1;
  my $tag2;

  return unless $fh->open("<$fn");

  while( <$fh> )
	{
	if (m/^[<>]/)
	  {
	  if ( (not defined $tag1)				# snarf first DNA\d+ or PRO\d+
		   and ( m/((?:DNA|PRO)\d+.*\[(?:min|full)\].*)/ ) )	# as tag
		{ $tag1 = $1; }
	  if ( not defined $tag2				# also keep initial >tag line
		   and ( m/^>(\S+)/ ) )				# as from affy sequences
		{ $tag2 = $1; }
	  }
	else
	  { $seq .= $_; }
	}
  $fh->close();

  $seq =~ s/\s+//g;

  $tag = $tag1 || $tag2;					# prefer tag1, but tag2 okay
  #dprint(3, "# read1 returns ({",length($seq),"},$tag)\n");
  return ( $seq , $tag );
}


# wrap -- line wrap a long sequence string
# no point in importing Text::Wrap just for this
# in: sequence (scalar), width
# out: array of lines (len < $width)
sub wrap
  {
  my $seq = shift;
  my $width = shift || 60;
  my (@lines) = ();
  dprint(4, "#wrap({",length($seq),"},$width)\n");
  while ( length($seq) > 0 )
	{
	#dprint(5, sprintf("#  %d %d {%s...}\n", $#lines+1, length($seq), substr($seq,0,5)));
	push( @lines, substr($seq,0,$width,''));
	}
  return ( @lines );
  }


sub dprint
  {
  my $level = shift;
  print(STDERR @_) if ($DEBUG >= $level );
  }

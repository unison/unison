Unison Loading and Updating				-*-outline-*-

This document describes the Unison loading and updating process. It is
intended for maintainers of a Unison database.

Unison loading and updating is mostly achieved through makefiles using
scripts in unison/sbin. There's is an ongoing effort to unify the
operation of these, but some tweaking and debugging may still be required.

Loading occurs in these phases:
- Loading auxiliary data
- Loading sequences
- Loading models (HMMs, threading backbones, etc)
- Inferring tax_ids for loaded sequences.
- Building sequence sets based on simple sequence data (init met, length)
  or associated data (origin, tax_id). This includes building sets of
  sequences for which results should be precomputed.
- Computing and loading results.
- Building sequence sets based on computed results.

Details about these loading phases are elaborated upon below.


* General loading 
Data are always loaded by the 'loader' user. The exact permissions on a
table for insert, update, or delete depend on the needs for that data
source.



* Auxiliary data loading
Auxiliary data refers to third party loaded into distinct schemas.  This
includes scop, swiss-prot taxonomy, go/gong, pdb, and others.  The intent
is to incorporate these with no (or very minor) changes.  These are
intentially distinct from the Unison schema and not dependent on it in any
way.

These schemas have same-named subdirectories in csb-db, and typically
Makefiles within which load or update the schemas.

Current auxiliary schemas:
** go (and GOng)
** pdb
** scop
** tax
** sst (aka GenenGenes; Genentech specific)

NB: homologene and MINT were errantly loaded into unison itself and
will be moved.


* Sequence loading
Sequences may be loaded from any source recognized by bioperl's SeqIO
module. Currently, fasta and Refseq-formatted files are loaded routinely.
See loading/pseq/Makefile for examples.

Sequences are loaded with aliases and annotations into origins. An alias
must be unique within the origin; if it is not, the previous sequence is
deprecated and the new sequence assumes the alias.

A typical data loading invocation is:
$ PGPASSWORD=thepass make Refseq.load


* Model loading
Models are any entity to which a sequence may be aligned. Currently,
models are other sequences, HMMs, PSSMs, structure templates, or regular
expressions.

** Prospect2 templates
** HMMs (Pfam, in-house)
** PSSMs (Proceryon, CDD)
** genome assemblies
** regexps


* Data derived in Unison (e.g., by plpgsql code):
** infer_tax_id
select update_tax_ids();

** mv_best_annotation

** update sets
select update_psets_intrinsic();




* Precomputed results
Results are typically precomputed for the runA, runB, or runC set,
depending on the computational cost.

A typical data loading invocation is:
$ export PGPASSWORD=thepass
$ make runA.ids runA-todo.ids
$ make runA-todo.load (or) make qsub/runA-todo.load

You may also break large runs into pieces:
$ make runA.ids runA-todo.ids
$ make runA-todo-l100
  breaks runA-todo.ids into 100-id files in a new runA-todo-l100/ directory
$ make runA-todo-l100-load (or) runA-todo-l100-qload
  runs (or submits to qsub) each of the 100-id files



** BLAST (against reliable sequences and PDB sequences)
** run-blat
** run-pahmm
** run-paprospect2
** run-papssm
** run-pfregexp
** run-protcomp; 
** run-tmdetect (in-house); 1500/min
** run-tmhmm
secondary structure
sigcleave
antigenic
bigpi
signalp


* Extrinsic sequence sets
secreted
tm (1,5,7)
intracellular
PM
patented
typeI
typeII


* Post-loading tasks

** move blast database files to common location

** generate schema docs

** mv_best_annotation

** update stats

** load new scop
scop2pmodel 


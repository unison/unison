#! /usr/bin/env perl
#-------------------------------------------------------------------------------
# NAME: load-pmap
# PURPOSE: Parse PMAP psl output for protein-to-genome alignments. load
#          output into Unison.
#
# $Id: load-pmap,v 1.5 2005/11/29 04:15:09 rkh Exp $
#-------------------------------------------------------------------------------

use strict;
use warnings;
use Bio::Tools::ProteinToGenomeBlat;
use Getopt::Long;
use Unison;
use Unison::Exceptions;
use Data::Dumper;

sub load_seq_alns ($@);
sub load_aln_hsps ($@);

my %opts =
  (
   genasm_id => undef,
   pct_ident_cutoff => 80,
   score_cutoff => 80,
   ident_cutoff => 25,
   verbose => 0,
   params => undef,
   params_id => undef
  );

GetOptions(\%opts,
  'pct_ident_cutoff|i=i',
  'genasm_id|g=i',
  'score_cutoff|s=i',
  'help',
  'verbose|v+',
  'params|p=s'
) || usage();

($#ARGV == 0
 and defined $opts{params}
 and defined $opts{genasm_id})
  || usage();


my $u = new Unison(dbname=>'csb-dev', username=>'loader');

my $params_id = $u->get_params_id_by_name( $opts{params} );
(defined $params_id)
  || die( "Unable to retrieve params_id for name=$opts{params}" );

my $psl_in = new Bio::Tools::ProteinToGenomeBlat( -file => $ARGV[0] );


my $last_pseq_id = -1;
my @alns;

while ( my $aln = $psl_in->next_result() ) {
  my $pseq_id;

  if ( not defined $aln->seq_id ) {
	warn( "ERROR: line $.: result seq_id is undefined; skipping.\n",
		  $_, "\n" );
	next RESULT;
  }

  ($pseq_id) = $aln->seq_id =~ m/Unison:(\d+)/;
  if ( not defined $pseq_id ) {
    die( "ERROR: can't parse pseq_id from seq_id=",$aln->seq_id,"\n",
		 "Source sequences aren't from Unison!\n");
  }

  if ( $pseq_id != $last_pseq_id ) {
	load_seq_alns($u,@alns);
	undef @alns;
	$last_pseq_id = $pseq_id;
  }

  push(@alns,$aln);
}

load_seq_alns($u,@alns);

exit(0);



############################################################################
## Internal Functions

sub load_seq_alns ($@) {
  my ($u,@alns) = @_;
  return unless @alns;
  my ($pseq_id) = $alns[0]->seq_id =~ m/Unison:(\d+)/; # error-checked in calling loop
  my $aln_sth = $u->prepare_cached( 'select ins_pmap_aln( NULL, ?, ?, ?, ?, ?, ?, ?, ? )' );

  printf(STDERR "# Unison:%d (<=%d alignments):\n", $pseq_id, $#alns+1);


 RETRY:
  try {

	$u->begin_work();
	for (my $i=0; $i<=$#alns; $i++) {
	  my $aln = $alns[$i];
	  ($pseq_id) = $aln->seq_id =~ m/Unison:(\d+)/;	# already error-checked in calling loop
	  my @pct_ident  = $aln->get_tag_values('percent_id');
	  my @ident      = $aln->get_tag_values('ident');
	  my @qgap_cnt   = $aln->get_tag_values('qgap_cnt');
	  my @qgap_bases = $aln->get_tag_values('qgap_bases');
	  my @tgap_cnt   = $aln->get_tag_values('tgap_cnt');
	  my @tgap_bases = $aln->get_tag_values('tgap_bases');

	  # filter by insertion criteria
	  if (    $aln->score < $opts{score_cutoff}
		   or $pct_ident[0] < $opts{pct_ident_cutoff}
		   or $ident[0] < $opts{ident_cutoff} ) {
		if ( $opts{verbose} ) {
		  printf(STDERR "  skipped aln %d: ident: %d, %%ident: %d, score: %4.2f\n",
				 $i,$ident[0],$pct_ident[0],$aln->score);
		}
		next;
	  }

	  my ($chr,@hsp_ids) = load_aln_hsps($u,$pseq_id,$aln);
	  $aln_sth->execute( $pseq_id, $ident[0],
						 $qgap_cnt[0], $qgap_bases[0],
						 $tgap_cnt[0], $tgap_bases[0],
						 $params_id, $opts{genasm_id} );

	  if ( $opts{verbose} ) {
		printf(STDERR "  loaded aln %d: chr %s, ident: %d, %%ident: %d, score: %4.2f, exons: %d\n",
			   $i,$chr,$ident[0],$pct_ident[0],$aln->score,($#hsp_ids+1));
	  }
	}

	my $z = $u->upd_run_history($pseq_id,$params_id,undef,undef);
	$u->commit();
	print(STDERR "  run_history tickled and load committed at $z\n");

  } catch Unison::Exception with {

	$u->rollback();

    my $e = shift;
	if ($e->error() =~ m/deadlock detected/) {
      warn("$e; retrying.\n");
      goto RETRY;
    } elsif ( $e->error() =~ m/unique constraint/ ) {
	  warn($e);
	} else {
	  die("$e");
	}

  };

  $aln_sth->finish();

}


sub load_aln_hsps ($@) {
  my ($u,$pseq_id,$aln) = @_;
  my $hsp_sth = $u->prepare_cached( 'select ins_pmap_hsp( ?, ?, ?, ?, ?, ?, ?, ?, ? )' );
  my $chr;
  my @hsp_ids;

  foreach my $f ( $aln->get_SeqFeatures() ) {
	if ( not defined $f->seq_id ) {
	  throw Unison::Exception("line $.: feature seq_id is undefined");
	}
	($chr) = $f->seq_id =~ m/chr(\w+)/;
	if ( not defined $chr ) {
	  throw Unison::Exception("line $.: chr is undefined");
	}
	$hsp_sth->execute( $opts{genasm_id},  $chr,
					   (( $f->strand > 0 ) ? 'true' : 'false'),
					   $f->start, $f->end, $pseq_id, $f->hstart,
					   $f->hend, $params_id );
	push(@hsp_ids,$hsp_sth->fetchrow_array);
  }

  $hsp_sth->finish();

  return ($chr,@hsp_ids);
}


sub usage {
  die( "USAGE: load-pmap [OPTIONS] -g <genasm_id> |--genasm_id <genasm_id> -p <param_name> |--params_id <param_name> output.psl\n" ,
    "\tOPTIONS:\n",
    "\t\t-h|--help: output USAGE statement and exit\n",
    "\t\t-i <cutoff> | --pct_ident_cutoff=<cutoff>: only accept HSPs with percent identity greater than cutoff\n",
    "\t\t-s <cutoff> | --score_cutoff=<cutoff>: only accept HSPs with score greater than cutoff\n" );
}

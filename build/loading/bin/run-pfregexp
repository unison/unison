#!/usr/bin/env perl
# run-pfregexp -- insert pfregexp entries into Unison

# NOTE: this script should be fixed to run on only on the given sequence list


use warnings;
use strict;

use Unison;
use Unison::SQL;
use Getopt::Long qw(:config gnu_getopt);
use Data::Dumper;
use Error qw(:try);
use Base::arrayUtilities qw(acomm);

sub get_regexps($$$);
sub get_matching_pseq_ids($@);
sub firstN($@);

my %opts = (
			'debug' => 0,
			'params_id' => undef,
			'pmodelset_id' => undef,
			'origin_id' => undef,
	                'update'    => 0,
			'verbose' => 1,
		   );
GetOptions(\%opts,
		   'debug+',
		   'pmodelset_id|M=i@',
		   'origin_id|O=i@',
	           'update',
		   'verbose!',
		  )
  or die("$0: bad usage\n");


if ($opts{debug}) {
  select STDERR; $|++;
  select STDOUT; $|++;
  print Dumper(\%opts);
}

my $u = new Unison( dbname=>'csb-dev', username=>'loader' );
my %regexps;


# regexp currently have only one params type, so we can get
# it directly from Unison
$opts{params_id} = $u->get_params_id_by_name('regexp');
(defined $opts{params_id})
  || die("$0: couldn't find params_id for params `regexp'\n");

# for @ of pmodelset_id and/or @ of origin_id, get list of ppmodel_ids
if (not (defined $opts{'pmodelset_id'} or defined $opts{'origin_id'})) {
  die("$0: you must specify either --modelset_id or --origin_id to select models\n");
}

# get the models as a hash of pmodel_id => regexp
%regexps = get_regexps($u,$opts{pmodelset_id},$opts{origin_id});
my @pmodel_ids = sort keys %regexps;
printf("%d models selected\n", $#pmodel_ids+1);


my (@pseq_ids) = @ARGV ? map {eval "$_"} @ARGV : map { chomp;$_ } <>;
my $N = $#pseq_ids+1;
my $M = $#pmodel_ids+1;
# Filter the requested pseq_ids for those which actually hit any of the
# regexps. If the number of pseq_ids is large, we can save the time to
# fetch each sequence by doing a server-side scan for pseq_ids which hit
# ANY of the regexps, and using that locally to determine which sequences
# to fetch.
# This is very slow when the number of regular expressions to match is large, 
# so restrict to smaller modelsets
my %hits;
if ($N >= 10000 and $M <= 100) {
  print(STDERR "# using server-side expression matching...\n");
  %hits = map {$_=>1} get_matching_pseq_ids($u,values %regexps);
  my $nhits = scalar(keys %hits);
  printf(STDERR "# matched %d/$N (%5.1f %%) sequences\n",
		 $nhits, $nhits/$N*100);
}


my $insert_sth = $u->prepare('insert into pfregexp (params_id,pseq_id,pmodel_id,start,stop) values (?,?,?,?,?)');


PSEQ_ID:
for(my $i=0; $i<=$#pseq_ids; $i++) {
  my $pseq_id = $pseq_ids[$i];
  my $leader = sprintf("\rUnison:%-8d %d/%d (%5.1f%%)", $pseq_id, $i+1, $N, ($i+1)/$N*100);
  print(STDERR $leader);

  foreach my $m (defined $opts{pmodelset_id} ? @{$opts{pmodelset_id}} : undef) {
  foreach my $o (defined $opts{origin_id} ? @{$opts{origin_id}} : undef) {
	my $ran_on = $u->get_run_timestamp($pseq_id,$opts{params_id},$o,$m);
	if (defined $ran_on and not $opts{update}) {
	  ## IMPORTANT NOTE: This is arguably broken when running with
	  ## multiple pmodelset_id and/or origin_id arguments. Specifically,
	  ## this conservatively skips running this entire sequence if ANY of
	  ## the m/o compbinations are present. This may leave some m/o
	  ## combinations un-run.
	  print(STDERR ": run with these options on $ran_on; skipping\n");
	  next PSEQ_ID;
	}
  }}

  if (not %hits or exists $hits{$pseq_id}) {
	my @mbe;
	my $seq = $u->get_sequence_by_pseq_id($pseq_id);
	if (not defined $seq) {
	  warn("couldn't retrieve Unison:$pseq_id; skipping\n");
	  next PSEQ_ID;
	}
	foreach my $pmodel_id (@pmodel_ids) {
	  my $re = qr/$regexps{$pmodel_id}/;
	  while ($seq =~ m/$re/g) {
		my $e = pos($seq);
		push(@mbe,[$pmodel_id,$e-length($&)+1,$e])
	  }
	}

	printf(STDERR "%4d features...", $#mbe+1);
	foreach my $mbe (@mbe) {
	  try {
	    if($opts{update}) {
	      my $dsql = 'delete from pfregexp where pseq_id=? and params_id=? and pmodel_id=?';
	      my $dsth = $u->prepare($dsql);
	      $dsth->execute($pseq_id,$opts{params_id},$mbe->[0]);
	    }
	    $insert_sth->execute($opts{params_id},$pseq_id,@$mbe);
	  } catch Unison::Exception::DBIError with {
		my $e = $_[0];
		if ("$e" !~ m/duplicate key/) {
		  die("$leader\n$e\n");
		};
		# else, ignore it
	  };
	}
  }

  $u->upd_run_histories($pseq_id,$opts{params_id},$opts{origin_ids},$opts{pmodelset_id});
}
print(STDERR "\n");



sub get_regexps($$$) {
  # return hash of pmodel_id => regexp for pmodelset and origin ids.
  my ($u,$m,$o) = @_;
  my $sql = new Unison::SQL;
  $sql->columns('M.pmodel_id,M.regexp')
      ->table('pmregexp M');
  if (defined $m) {
	$sql->join('pmsm_pmregexp S on M.pmodel_id=S.pmodel_id')
	    ->where('S.pmodelset_id in (' . join(',',@$m) . ')');
  }
  if (defined $opts{origin_id}) {
	$sql->where('M.origin_id in (' . join(',',@$o) . ')' );
	$sql->order('M.origin_id');
  }
  $sql->order('M.pmodel_id');
  return( map {$_->[0]=>$_->[1]} @{$u->selectall_arrayref("$sql")} );
}

sub get_matching_pseq_ids($@) {
  my ($u,@re) = @_;
  my $sql = 'select distinct pseq_id from pseq where ('
	. join(' or ', map {"seq~'$_'"} @re)
	. ') order by pseq_id';
  return( map {@$_} @{$u->selectall_arrayref($sql)} );
}

sub firstN($@) {
  my $N = shift;
  return '' unless (defined @_);
  return join(',', $#_<$N ? @_ : (@_[0..$N],'...') );
}

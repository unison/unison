#!/usr/bin/env perl
# $Id: run-pahmm,v 1.10 2005/03/29 04:10:45 rkh Exp $
# run-pahmm -- run hmmer on specified sequences

# TODO:
# - currently fetches 1, runs 1, loads 1; better to run in a pipe, or in
# batches of sequences if that's problematic. ldhmmer will particularly
# like this

use warnings;
use strict;
use Bio::PrimarySeq;
use Bio::SearchIO;
use Bio::SeqIO;
use Data::Dumper;
use Error qw(:try);
use File::Temp qw(tempfile tempdir);
use Getopt::Long qw(:config gnu_getopt);
use IO::File;
use IO::Pipe;
use Unison::Exceptions;
use Unison::SQL;
use Unison;


sub fetch_sequences ($$@);
sub get_pmodel_id ($);
sub run_and_load ($$);


my %pfams = 
  (
   '12fs' => {modelfile => '/gne/compbio/share/pfam-12.0/Pfam_fs',
			  origin => 'Pfam_fs 12.0',
			  params => 'Pfam_fs 12.0'},
   '14fs' => {modelfile => '/gne/compbio/share/pfam-14.0/Pfam_fs.hmmb',
			  origin => 'Pfam_fs 14.0',
			  params => 'Pfam_fs 14.0'},
   '14ls' => {modelfile => '/gne/compbio/share/pfam-14.0/Pfam_ls.hmmb',
			  origin => 'Pfam_ls 14.0',
			  params => 'Pfam_ls 14.0'},
   '14fsld' => {modelfile => '/gne/compbio/share/pfam-14.0/Pfam_fs.hmmb',
			  origin => 'Pfam_fs 14.0',
			  params => 'Pfam_fs 14.0 (ldhmmer)'},
   '17fs' => {modelfile => '/gne/compbio/share/pfam-17.0/Pfam_fs.hmmb',
			  origin => 'Pfam_fs 17.0',
			  params => 'Pfam_fs 17.0'},
   '17ls' => {modelfile => '/gne/compbio/share/pfam-17.0/Pfam_ls.hmmb',
			  origin => 'Pfam_ls 17.0',
			  params => 'Pfam_ls 17.0'},
  );

my %opts = 
  (
   force => 0,
   params_id => undef,
   pmodelset_id => undef,
   verbose => 0,
   pfam => '17fs',
   'seqs-per-run' => 100
  );
GetOptions(\%opts,
		   'force|f+',
		   #'params_id|p=i',
		   'pmodelset_id|M=i@',
		   'pfam=s',
		   'verbose|v+',
		   'seqs-per-run|N=i',
		  ) || die("$0: you got usage issues, short stack\n");

(exists $pfams{$opts{pfam}})
  || die("$0: pfam $opts{pfam} doesn't exist\n");

print(STDERR "# using Pfam $opts{pfam}\n");
%opts = (%opts,%{$pfams{$opts{pfam}}});

my $temproot = "/tmp/run-pahmm-$$";
my $seqfn = "$temproot.fa";
my $hmmfn;  # filename will be set below


my $u = new Unison( dbname=>'csb-dev', username=>'loader' );

if (not defined $opts{params_id}) {
  $opts{params_id} = $u->get_params_id_by_name($opts{params});
  if (not defined $opts{params_id}) {
	die("$0: couldn't find params_id for params `$opts{params}'\n");
  }
}

if (not defined $opts{porigin_id}) {
  $opts{porigin_id} = $u->porigin_porigin_id_by_origin($opts{origin});
  if (not defined $opts{porigin_id}) {
	die("$0: couldn't find porigin_id for params `$opts{origin}'\n");
  }
}


if ( defined $opts{pmodelset_id} ) {
	$hmmfn = "$temproot.pfam";
	my $sql = new Unison::SQL;
	$sql->columns('distinct name')
		->table('pmhmm M');
	$sql->join('pmsm_pmhmm S on M.pmodel_id=S.pmodel_id')
		->where('S.pmodelset_id in (' . join(',',@{$opts{pmodelset_id}}) . ')');
	$sql->order('name');
		(@{$opts{'templates'}}) = map {@$_} @{$u->selectall_arrayref("$sql")};

	my $cmd = "hmm-extract <$opts{modelfile} @{$opts{'templates'}} >$hmmfn";
	print "$cmd\n" if $opts{verbose};
	system( $cmd );
	$? && die("$cmd: $!\n");
} else {
	$hmmfn = $opts{modelfile};
}

my $clo = $u->run_commandline_by_params_id($opts{params_id});
my @cl = (split(' ',$clo), '--acc', $hmmfn, $seqfn);
print "cl: ",join(' ',@cl),"\n" if $opts{verbose};

my @fields = qw(params_id pseq_id start stop pmodel_id mstart mstop gaps qgaps tgaps score eval);
my $pahmm_sth = $u->prepare_cached(sprintf("insert into pahmm (%s) values (%s)",
										   join(',',@fields), join(',',map {'?'} @fields)));


my (@pseq_ids) = @ARGV ? map {eval "$_"} @ARGV : map { chomp;$_ } <>;
my $N = $#pseq_ids+1;
my $n = 0;
my $totseqs = 0;
my $tothits = 0;
my $tothsps = 0;
my $toterrs = 0;

while( @pseq_ids ) {
  my (@ids) = splice(@pseq_ids,0,$opts{'seqs-per-run'});
  next unless fetch_sequences($u,$seqfn,@ids);
  my ($seqs,$hits,$hsps,$errs) = run_and_load($u,$seqfn);
  $totseqs += $seqs;
  $tothits += $hits;
  $tothsps += $hsps;
  $toterrs += $errs;

  my $Ncomp = $N - ($#pseq_ids+1);
  printf(STDERR "run-pahmm: $Ncomp/$N (%5.1f%% complete); $totseqs seqs; $tothits hits; $tothsps HSPs; $toterrs errors\n",
		 $Ncomp / $N * 100);
}


sub fetch_sequences ($$@) {
  # fetch sequences to temp file
  my $u = shift;
  my $seqfn = shift;
  my @pseq_ids = @_;
  my $nseq = 0;

  my $so = new Bio::SeqIO( -format => 'fasta',
						   -file => ">$seqfn" )
	|| die("! couldn't open $seqfn for writing\n");

  foreach my $pseq_id (@pseq_ids) {
	if ($u->already_ran($pseq_id,$opts{params_id},$opts{porigin_id},$opts{pmodelset_id})) {
	  warn("Unison:$pseq_id already run with these parameters\n");
	  next;
	}
	my $seq = $u->get_sequence_by_pseq_id( $pseq_id );
	if (not defined $seq) {
	  warn("\n! couldn't find sequence for pseq_id=$pseq_id\n");
	  next;
	}
	$so->write_seq( new Bio::PrimarySeq( -seq => $seq,
										 -id => "Unison:$pseq_id" ) );
	$nseq++;
  }
  $so->close();
  return $nseq;
}


sub run_and_load ($$) {
  my $u = shift;
  my $seqfn = shift;
  my $totseqs = 0;
  my $tothits = 0;
  my $tothsps = 0;
  my $toterrs = 0;

  my $hmmerpipe = new IO::Pipe;
  $hmmerpipe->reader( @cl )
	|| die("couldn't do @cl\n");
  my $in = new Bio::SearchIO(-format => 'hmmer',
							 -fh => $hmmerpipe);

  while( my $result = $in->next_result ) {	# "result" is a query sequence
	$totseqs++;
	my ($pseq_id) = $result->query_name() =~ m/Unison:(\d+)/;
	(defined $pseq_id)
	  || die("couldn't parse pseq_id from hmmer results\n");
	my $nhits = 0;
	my $nhsps = 0;

	try {
	  $u->begin_work();
	  while( my $hit = $result->next_hit ) {
		$nhits++;
		my $acc = $hit->name();
		my $pmodel_id = get_pmodel_id($acc);
		if (not defined $pmodel_id) {
		  die("\n! couldn't look up a pmodel_id for $acc in origin $opts{porigin_id}!\n");
		}

		while( my $hsp = $hit->next_hsp ) {
		  $nhsps++;
		  my @data = ($opts{params_id}, 
					  $pseq_id, $hsp->start('query'), $hsp->end('query'),
					  $pmodel_id, $hsp->start('hit'), $hsp->end('hit'),
					  $hsp->gaps('total'), $hsp->gaps('query'), $hsp->gaps('hit'),
					  int($hsp->score()), $hsp->evalue());
		  $pahmm_sth->execute(@data);
		}
	  }
	  my $z = $u->upd_run_histories($pseq_id,$opts{params_id},$opts{porigin_id},$opts{pmodelset_id});
	  $u->commit();
	  printf(STDERR "Unison:$pseq_id: $nhits hits, $nhsps HSPs; committed\n");
	  $tothits += $nhits;
	  $tothsps += $nhsps;
	} catch Unison::Exception with {
	  my $e = $_[0];
	  if ("$e" =~ m/duplicate key/ or "$e" =~ m/(?:over|under)flow/) {
		warn("\n$e\nUnison:$pseq_id load failed; rolling back.\n",);
		$u->rollback();
		$toterrs++;
	  } else {
		die("$e");
	  }
	};
  }

  $hmmerpipe->close();
  return( $totseqs, $tothits, $tothsps, $toterrs );
}



my %pmodel_id_cache;
sub get_pmodel_id ($) {
  my $acc = shift;
  if (not exists $pmodel_id_cache{$acc}) {
	my $sth = $u->prepare_cached('select pmodel_id from pmhmm where acc=? and porigin_id=? order by added desc');
	$sth->execute($acc,$opts{porigin_id});
	my $ids = $sth->fetchall_arrayref();
	return undef unless defined $ids;
	die("\n! found ",$#$ids+1," pmodel_ids for model acc $acc\n") if ($#$ids>0);
	$pmodel_id_cache{$acc} = $ids->[0]->[0];
  }
  return $pmodel_id_cache{$acc};
}

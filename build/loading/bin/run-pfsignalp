#!/usr/bin/env perl

#-------------------------------------------------------------------------------
# NAME run-pfsignalp
# PURPOSE: run sigcleave and load results into unison
# USAGE: run-pfsignalp [pseq_ids]
#
# $Id: run-pfsignalp,v 1.2 2003/10/17 23:45:04 cavs Exp $
#-------------------------------------------------------------------------------

use Unison;
use IO::File;
use Env qw(@PATH);
use Bio::SeqIO;
use Bio::PrimarySeq;
use Getopt::Long;
use warnings;
use strict;

my %opts = 
  (
   debug => 0
  );
GetOptions( \%opts,
      'debug|d+' )
  || die("$0: usage\n");


my $run_id = 6;                # hardwired for now
my $temp_in_fn =  "/tmp/run-pfsignalp-$$.fa";
my $temp_out_fn = "/tmp/run-pfsignalp-$$.out";

# signalp barfs on really small and large seqs
my $len_lower_cutoff = '50';
my $len_upper_cutoff = '3000';

my $u = new Unison;

my @cmd = ('signalp', split(' ',$u->run_commandline_by_run_id( $run_id )),$temp_in_fn,"1>$temp_out_fn");
my $seqio = new Bio::SeqIO( -format => 'fasta', -file => ">$temp_in_fn" );
my $sthnn = $u->prepare( 'insert into pfsignalpnn(pseq_id,start,stop,confidence,run_id) values (?,?,?,?,?)' );
my $sthhmm = $u->prepare( 'insert into pfsignalphmm(pseq_id,start,stop,confidence,siganchor_prob,max_cleavage_prob,run_id) values (?,?,?,?,?,?,?)' );

#my @list = Unison::utils::range_to_enum(@ARGV);
my @list = @ARGV;
for(my $i=0; $i<=$#list; $i++) {
  my $pseq_id = $list[$i];

  my $seq = $u->get_sequence_by_pseq_id( $pseq_id );
  printf(STDERR "retrieving Unison:%-8s (%5d AA) %4d/%4d %3d%% complete...\n",
     $pseq_id, length($seq), ($i+1), ($#list+1), ($i+1)/($#list+1)*100 );
  if      (not defined $seq) {
    warn("$0: Unison:$pseq_id doesn't exist\n");
    return;
  } elsif ((length($seq) < $len_lower_cutoff) || (length($seq) >  $len_upper_cutoff)) {
    printf(STDERR "skipping Unison:%s since its len (%d) not in the range of [%d .. %d]\n",
       $pseq_id, length($seq), $len_lower_cutoff , $len_upper_cutoff);
    next;
  }
    
  $seqio->write_seq( new Bio::PrimarySeq(-seq => $seq, -id  => "Unison:$pseq_id") );
}
$seqio->close();

# run signalp
system(join(' ',@cmd));

my $fp = new IO::File $temp_out_fn;
local $/='----------------------------------------------------------------------';
while(<$fp>){
  next if m/SignalP predictions/;
  if (my($id,$spos,$sprob,$spp,$sap,$mcsp,$hmme) = m/>(\S+).+mean S\s+(\S+)\s+(\S+).+Signal peptide probability:\s+(\S+)\s+Signal anchor probability:\s+(\S+)\s+Max cleavage site probability:\s+(\S+) between pos. (\S+) and/sm) {
    $id =~ m/^Unison:(\d+)/;
    my $pseq_id = $1;
    my ($nn_start,$nn_end) = split/-/,$spos,2;
    printf(STDERR "loading Unison:%-8s (NN:  sig_pep_prob: %.2f, cleavage_site: %d)\n",
           $pseq_id,$sprob,$nn_end);
    printf(STDERR "loading Unison:%-8s (HMM: sig_pep_prob: %.2f, sig_anchor_prob: %.2f, cleavage_site: %d, max_cleavage_prob: %.2f)\n",
           $pseq_id,$spp,$sap,$hmme,$mcsp);
    $sthnn->execute($pseq_id,$nn_start,$nn_end,$sprob,$run_id);
    $sthhmm->execute($pseq_id,'1',$hmme,$spp,$sap,$mcsp,$run_id);
    $u->last_run_update($pseq_id,$run_id);
  } else {
    die("missed $_");
  }
}
unlink $temp_in_fn, $temp_out_fn unless $ENV{'DEBUG'};

exit(0);

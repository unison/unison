#!/usr/bin/env perl
# run-paprospect -- run and insert prospect threads into Unison
# arguments: 
#   --params_id|-p <params_id>: params_id for loading (required)
#   --tfile|-t <template file>: file containing a list of templates (optional)
#   --update: force update (i.e. delete cooresponding rows in unison before inserting) (optional)
# usage: run-p2 [psql options] --params_id <params_id> [--tfile <template file>] [--update]
#
# $Id: run-paprospect,v 1.18 2005/05/11 21:53:41 rkh Exp $
#-------------------------------------------------------------------------------

use warnings;
use strict;

use Unison;
use Unison::SQL;
use Bio::Prospect::Options;
use Bio::Prospect::LocalClient;
use Bio::Prospect::Exceptions;
use Getopt::Long qw(:config gnu_getopt);
use Data::Dumper;
use Error qw(:try);



my %opts = 
  (
   'debug' => 0,
   'dry-run' => 0,
   'params_id' => undef,
   'pmodelset_id' => undef,
   'porigin_id' => undef,
   'template-file' => undef,				# file of template names
   'templates' => undef,					# template names
   'update' => 0,							# try update before insert
   'verbose' => 1,
  );
GetOptions
  (
   \%opts,
   'debug+',
   'params_id|p=i',
   'pmodelset_id|M=i@',
   'porigin_id|o=i@',
   'template-file|tfile|T=s',
   'templates|t=s@',
   'update',
   'verbose!',
   'dry-run|n'
  )
  or die("$0: bad usage\n");


(defined $opts{params_id})
  || die( "$0: --params_id|-p parameter missing\n" );
if (defined $opts{'template-file'} or defined $opts{'templates'}) {
  (defined $opts{'template-file'} and defined $opts{'templates'})
	&& die("$0: may not specify both --template-file and --templates\n");
  (defined $opts{'pmodelset_id'} or defined $opts{'porigin_id'})
	&& die("$0: may not specify pmodelset_id or porigin_id with --template-file or --templates\n");
}


if ($opts{debug}) {
  select STDERR; $|++;
  select STDOUT; $|++;
  print Dumper(\%opts);
}

my @pseq_ids = map {eval "$_"} @ARGV;
my $N = $#pseq_ids+1;


my $u = new Unison( dbname=>'csb-dev', username=>'loader' );

my $po = $u->get_p2options_by_params_id($opts{params_id});

if (defined $opts{'pmodelset_id'} or defined $opts{'porigin_id'}) {
  # given pmodelset_id and/or porigin_id, shove list of models in $opts{templates}
  my $sql = new Unison::SQL;
  $sql->columns('acc')
	->table('pmprospect M');
  if (defined $opts{pmodelset_id}) {
	$sql->join('pmsm_prospect S on M.pmodel_id=S.pmodel_id')
	  ->where('S.pmodelset_id in (' . join(',',@{$opts{pmodelset_id}}) . ')');
  }
  if (defined $opts{porigin_id}) {
	$sql->where('M.porigin_id in (' . join(',',@{$opts{porigin_id}}) . ')' );
  }
  $sql->order('acc');
  (@{$opts{'templates'}}) = map {@$_} @{$u->selectall_arrayref("$sql")};
}

if (defined $opts{'templates'}) {
  $po->{templates} = $opts{templates};
  printf(STDERR "threading against %d templates\n", 1+$#{$opts{templates}});
} elsif (defined $opts{'template-file'}) {
  $po->{tfile} = $opts{'template-file'}
} else {
  $po->{tfile} = '/gne/compbio/share/prospect/tfiles/all';
}

my $temproot = $ENV{TMPDIR} || '/tmp/';
my $pc = new Bio::Prospect::LocalClient(options => $po,
										temproot => $temproot
									   );




PSEQ_ID: while( my $pseq_id = shift(@pseq_ids) ) {
  my $leader = "\rUnison:$pseq_id";
  print(STDERR $leader);

  foreach my $m (defined $opts{pmodelset_id} ? @{$opts{pmodelset_id}} : undef) {
  foreach my $o (defined $opts{porigin_id} ? @{$opts{porigin_id}} : undef) {
	my $ran_on = $u->get_run_timestamp($pseq_id,$opts{params_id},$o,$m);
	if (defined $ran_on and not $opts{update}) {
	  ## IMPORTANT NOTE: This is arguably broken when running with
	  ## multiple pmodelset_id and/or porigin_id arguments. Specifically,
	  ## this conservatively skips running this entire sequence if ANY of
	  ## the m/o compbinations are present. This may leave some m/o
	  ## combinations un-run.
	  if (not $opts{update}) {
		print(STDERR "$leader: run with these options on $ran_on; skipping\n");
		next PSEQ_ID;
	  }
	  print(STDERR "$leader: run with these options on $ran_on; running anyway\n");
	}
  }}



  my $seq = $u->get_sequence_by_pseq_id( $pseq_id );
  $leader .= " (" . length($seq) . " AA)";

  my (@summaries);
  try {
	print(STDERR "$leader: threading...");
    (@summaries) = $pc->thread_summary( $seq );
  } catch Bio::Prospect::RuntimeError with {
	print(STDERR $_[0]);
    print STDERR "Skipping this pseq_id ($pseq_id)\n";
    next PSEQ_ID;
  } catch Bio::Prospect::Exception with {
	print(STDERR $_[0]);
    print STDERR "Skipping this pseq_id ($pseq_id)\n";
    next PSEQ_ID;
  };

  if ($opts{'dry-run'}) {
	print(STDERR "done\n");
	next;
  }

  for( my $i=0; $i<=$#summaries; $i++) {
	my $ts = $summaries[$i];
	printf(STDERR "$leader: loading %8s (%4d/%4d %3d%%)...", 
		   $ts->tname(), ($i+1), ($#summaries+1), ($i+1)/($#summaries+1)*100 );
    $u->delete_thread($pseq_id,$opts{params_id},$ts) if $opts{update};
	try {
	  $u->insert_thread($pseq_id,$opts{params_id},$ts);
	} catch Unison::Exception::DBIError with {
	  print(STDERR "\n$_[0]");
	};
  }

  my $z = $u->upd_run_histories($pseq_id,
								$opts{params_id},
								$opts{porigin_id},
								$opts{pmodelset_id});

  print(STDERR "done; history tickled ($z)\n");
}


############################################################################
# $Log: run-paprospect,v $
# Revision 1.18  2005/05/11 21:53:41  rkh
# periodic sync
#
# Revision 1.17  2005/03/22 05:44:23  rkh
# updated for /gne/ and linux-2.6
#
# Revision 1.16  2004/12/24 00:09:46  rkh
# 2004 sync
#
# Revision 1.15  2004/06/25 00:20:27  rkh
# periodic sync
#
# Revision 1.14  2004/06/04 00:04:07  rkh
# periodic sync
#
# Revision 1.13  2004/04/02 00:34:05  rkh
# periodic sync
#
# Revision 1.12  2004/02/25 20:47:12  rkh
# added exception handling
#
# Revision 1.11  2004/02/24 21:49:08  rkh
# * added ran_on; check IMPORTANT NOTE for clarification
#
# Revision 1.10  2004/02/24 19:20:57  rkh
# periodic sync
#
# Revision 1.9  2004/01/08 02:17:38  rkh
# sync with DEV
#
# Revision 1.8  2003/10/28 22:29:05  rkh
# * new Unison doesn't require special handling for PGPASSWORD (see U::DBI)
#
# Revision 1.6  2003/06/19 00:14:36  rkh
# * reworked options to use hashes
# * set $po->{tfile} only when $opt{tfile} is set
# * pretty print progress
#

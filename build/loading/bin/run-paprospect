#!/usr/bin/env perl
# run-paprospect -- run and insert prospect threads into Unison
# arguments: 
#   --params_id|-p <params_id>: params_id for loading (required)
#   --tfile|-t <template file>: file containing a list of templates (optional)
#   --update: force update (i.e. delete cooresponding rows in unison before inserting) (optional)
# usage: run-p2 [psql options] --params_id <params_id> [--tfile <template file>] [--update]
#
# $Id: run-paprospect,v 1.20 2006/03/16 19:06:56 mukhyala Exp $
#-------------------------------------------------------------------------------

use warnings;
use strict;

use Unison;
use Unison::SQL;
use Bio::Prospect::File;
use Bio::Prospect::ThreadSummary;
use Bio::Prospect::Exceptions;
use Bio::SeqIO;
use Getopt::Long qw(:config gnu_getopt);
use Data::Dumper;
use Error qw(:try);
use File::Temp qw/tempfile/;


my %opts = 
  (
   'debug' => 0,
   'dry-run' => 0,
   'params_id' => undef,
   'pmodelset_id' => undef,
   'origin_id' => undef,
   'template-file' => undef,				# file of template names
   'templates' => undef,					# template names
   'update' => 0,							# try update before insert
   'verbose' => 1,
  );
GetOptions
  (
   \%opts,
   'debug+',
   'params_id|p=i',
   'pmodelset_id|M=i@',
   'origin_id|o=i@',
   'template-file|tfile|T=s',
   'templates|t=s@',
   'update',
   'verbose|v',
   'dry-run|n'
  )
  or die("$0: bad usage\n");


(defined $opts{params_id})
  || die( "$0: --params_id|-p parameter missing\n" );
if (defined $opts{'template-file'} or defined $opts{'templates'}) {
  (defined $opts{'template-file'} and defined $opts{'templates'})
	&& die("$0: may not specify both --template-file and --templates\n");
  (defined $opts{'pmodelset_id'} or defined $opts{'origin_id'})
	&& die("$0: may not specify pmodelset_id or origin_id with --template-file or --templates\n");
}


if ($opts{debug}) {
  select STDERR; $|++;
  select STDOUT; $|++;
  print Dumper(\%opts);
}

my @pseq_ids = map {eval "$_"} @ARGV;
my $N = $#pseq_ids+1;


my $u = new Unison( dbname=>'csb-dev', username=>'loader' );
my @cl = (@{$u->selectall_arrayref("select commandline from params where params_id=$opts{params_id}")->[0]});
if (defined $opts{'pmodelset_id'} or defined $opts{'origin_id'}) {
  # given pmodelset_id and/or origin_id, shove list of models in $opts{templates}
  my $sql = new Unison::SQL;
  $sql->columns('acc')
	->table('pmprospect M');
  if (defined $opts{pmodelset_id}) {
	$sql->join('pmsm_pmprospect S on M.pmodel_id=S.pmodel_id')
	  ->where('S.pmodelset_id in (' . join(',',@{$opts{pmodelset_id}}) . ')');
  }
  if (defined $opts{origin_id}) {
	$sql->where('M.origin_id in (' . join(',',@{$opts{origin_id}}) . ')' );
  }
  $sql->order('acc');
  (@{$opts{'templates'}}) = map {@$_} @{$u->selectall_arrayref("$sql")};
}

if (defined $opts{'templates'}) {

  my ($fh,$fn) = File::Temp::tempfile( UNLINK => 1,SUFFIX => '.lst' );
  $fh->print(join("\n",@{$opts{templates}}),"\n");
  $fh->close();
  push(@cl, '--tfile ', $fn);
  printf(STDERR "threading against %d templates\n", 1+$#{$opts{templates}});

} elsif (defined $opts{'template-file'}) {
  push(@cl, '--tfile ', $opts{'template-file'});
  printf(STDERR "threading against templates in %s\n", $opts{'template-file'});
}




PSEQ_ID: while( my $pseq_id = shift(@pseq_ids) ) {
  my $leader = "\rUnison:$pseq_id";
  print(STDERR $leader);

  foreach my $m (defined $opts{pmodelset_id} ? @{$opts{pmodelset_id}} : undef) {
  foreach my $o (defined $opts{origin_id} ? @{$opts{origin_id}} : undef) {
	my $ran_on = $u->get_run_timestamp($pseq_id,$opts{params_id},$o,$m);
	if (defined $ran_on and not $opts{update}) {
	  ## IMPORTANT NOTE: This is arguably broken when running with
	  ## multiple pmodelset_id and/or origin_id arguments. Specifically,
	  ## this conservatively skips running this entire sequence if ANY of
	  ## the m/o compbinations are present. This may leave some m/o
	  ## combinations un-run.
	  if (not $opts{update}) {
		print(STDERR "$leader: run with these options on $ran_on; skipping\n");
		next PSEQ_ID;
	  }
	  print(STDERR "$leader: run with these options on $ran_on; running anyway\n");
	}
  }}



  my $seq = $u->get_sequence_by_pseq_id( $pseq_id );
  $leader .= " (" . length($seq) . " AA)";

  my ($seqfh,$seqfn) = File::Temp::tempfile( UNLINK => 1,SUFFIX => '.fasta' );
  my $so = new Bio::SeqIO( -format => 'fasta',
			   -file => ">$seqfn" )
    || die("! couldn't open $seqfn for writing\n");
  $so->write_seq( new Bio::PrimarySeq( -seq => $seq,
				       -id => "Unison:$pseq_id" ) );
  my @cmd = @cl;
  my (@summaries);


  print(STDERR "$leader: threading...");
  push(@cmd,$seqfn);
  print STDERR "@cmd\n" if($opts{verbose});
  system( join " ",@cmd );
  $? && die("FAILED: @cmd: $!\n");
  (@summaries) = xml2threadsummaries( "$seqfn.xml");

  if ($opts{'dry-run'}) {
	print(STDERR "done\n");
	next;
  }

  for( my $i=0; $i<=$#summaries; $i++) {
	my $ts = $summaries[$i];
	printf(STDERR "$leader: loading %8s (%4d/%4d %3d%%)...", 
		   $ts->tname(), ($i+1), ($#summaries+1), ($i+1)/($#summaries+1)*100 );
    $u->delete_thread($pseq_id,$opts{params_id},$ts) if $opts{update};
	try {
	  $u->insert_thread($pseq_id,$opts{params_id},$ts);
	} catch Unison::Exception::DBIError with {
	  print(STDERR "\n$_[0]");
	};
  }

  my $z = $u->upd_run_histories($pseq_id,
								$opts{params_id},
								$opts{origin_id},
								$opts{pmodelset_id});

  print(STDERR "done; history tickled ($z)\n");
}

sub xml2threadsummaries {
  my $xfn = shift || die "xml2threads expects an xml file\n";

  my $pf = new Bio::Prospect::File;
  $pf->open( "<$xfn" ) || die("could not open $xfn\n");
  my @ts;
  while( my $t = $pf->next_thread() ) {
    push @ts, new Bio::Prospect::ThreadSummary( $t );;
  }
  return( @ts );
}

############################################################################
# $Log: run-paprospect,v $
# Revision 1.20  2006/03/16 19:06:56  mukhyala
# changes for use of unison/bin/gne_prospect
#
# Revision 1.19  2005/10/09 09:39:31  rkh
# s/prospect2/prospect/
#
# Revision 1.18  2005/05/11 21:53:41  rkh
# periodic sync
#
# Revision 1.17  2005/03/22 05:44:23  rkh
# updated for /gne/ and linux-2.6
#
# Revision 1.16  2004/12/24 00:09:46  rkh
# 2004 sync
#
# Revision 1.15  2004/06/25 00:20:27  rkh
# periodic sync
#
# Revision 1.14  2004/06/04 00:04:07  rkh
# periodic sync
#
# Revision 1.13  2004/04/02 00:34:05  rkh
# periodic sync
#
# Revision 1.12  2004/02/25 20:47:12  rkh
# added exception handling
#
# Revision 1.11  2004/02/24 21:49:08  rkh
# * added ran_on; check IMPORTANT NOTE for clarification
#
# Revision 1.10  2004/02/24 19:20:57  rkh
# periodic sync
#
# Revision 1.9  2004/01/08 02:17:38  rkh
# sync with DEV
#
# Revision 1.8  2003/10/28 22:29:05  rkh
# * new Unison doesn't require special handling for PGPASSWORD (see U::DBI)
#
# Revision 1.6  2003/06/19 00:14:36  rkh
# * reworked options to use hashes
# * set $po->{tfile} only when $opt{tfile} is set
# * pretty print progress
#

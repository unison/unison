#! /usr/bin/env perl

my $usage = <<'EOU';
#-------------------------------------------------------------------------------
# NAME: load-pseq
# PURPOSE: load sequence files into Unison
# USAGE: load-pseq ARGUMENTS OPTIONS <seq files ...>
# ARGUMENTS (required):
#   --origin|-o <origin>: name of origin
#   --format|-f <format>: name of input file format (any format allowed by Bio::SeqIO)
# OPTIONS:
#   --start-after|--startafter <acc>: start parsing input file after this acc
#   --incl-subex|--inclsubex: flag to include suboptimal gene predictions
#   --verbose|-v: flag to output more processing information
#
# $Id: load-pseq,v 1.15 2005/03/22 05:48:20 rkh Exp $
#------------------------------------------------------------------------------

EOU

use warnings;
use strict;
use Bio::SeqIO;
use Getopt::Long qw(:config gnu_getopt);
use Unison;
use Unison::Exceptions;
use Unison::Utilities::misc qw(clean_sequence sequence_md5);
use IO::Zlib;
use IO::File;


sub tally ($%);
sub process_stream ($$);
sub process_seq ($$$$);


# acceptable file formats (courtesy of Bioperl)
my @af = qw(fthelper multifile abi ace alf asciitree bsml chadoxml ctf
		   embl exp fasta fastq game gcg genbank kegg largefasta locuslink
		   metafasta phd pir pln qual raw scf swiss tab tigr ztr);
my %af = map { $_=>1 } @af;


my %opts = (
			origin => undef,
			format => undef,
			'start-after' => undef,
			'include-subex' => 0,
			'verbose' => 0
);
GetOptions( \%opts,
			'origin|o=s',
			'format|f=s',
			'start-after|startafter|A=s',
			'verbose|v',
			'incl-subex|inclsubex' )
  || die("$0: bad usage:\n$usage\n");


(defined $opts{origin})
  || die("$0: --origin (-o) is mandatory\n$usage\n");
(defined $opts{format} && $af{lc($opts{format})})
  || die("$0: --format (-f) is mandatory and must be one of (",
		 join(',',sort {$a cmp $b} keys %af),")\n$usage\n");


my $u = new Unison( dbname=>'csb-dev', username=>'loader' );

#$u->do("update pg_settings set setting='debug' where name='client_min_messages'");

$opts{porigin_id} = $u->porigin_si_porigin_id($opts{origin});
(defined $opts{porigin_id})
  || die("couldn't lookup or insert origin $opts{origin}\n");


my %totals = map { $_=>0 } qw(nseen nadded nskipped nfailed naliases);

foreach my $fn ( @ARGV ) {
  my $fh;
  if ($fn =~ m/\.gz$/) {
	# die("Reading from gzipped files is currently broken. Sorry.\n");
	# dang, I can't remember why this is broken!
	# okay, I uncommented this and I think it works.
	# Perhaps it appeared broken because IO::Zlib didn't honor $/ ?
	$fh = new IO::Zlib;
	$fh->open($fn,'rb')
	  || die("$fn: $!\n");
  } else {
	$fh = new IO::File;
	$fh->open($fn)
	  || die("$fn: $!\n");
  }

  my $stream = Bio::SeqIO->new(-fh => $fh, 
							   -format => $opts{format});
  my $stats = process_stream($u,$stream);
  print(STDERR tally($fn,%$stats), "\n");

  $totals{$_} += $stats->{$_} for keys %$stats;
  $fh->close();
}

print(STDERR tally('totals',%totals), "\n");

if ($totals{nfailed} > 0) {
  die("! WARNING: Some sequence and/or aliases failed; origin.last_updated NOT tickled\n");
}

if ($totals{nadded} > 0) {
  print( "update porigin set last_updated='",
		 $u->porigin_last_updated($opts{porigin_id},1),
		 "' where porigin_id=$opts{porigin_id}\n");
} else {
  warn("! WARNING: No sequences loaded; origin.last_updated NOT tickled\n");
}




###########################################################################
## INTERNALS

sub tally ($%) {
  my ($src,%stats) = @_;
  sprintf('%-30s %7d seen, %7d added, %7d skipped, %7d failed, %7d aliases',
		  (length($src)>29 ? '...'.substr($src,-26) : $src).':',
		  @stats{qw(nseen nadded nskipped nfailed naliases)});
}



## NAME: process_stream
## PURPOSE: parse Bio::SeqIO stream and load sequences into Unison
## ARGUMENTS: Bio::SeqIO object, option hashref:
##'origin' => name of porigin (REQUIRED)
##  'start-after' => skip seqs until this accession
##  'incl-subex' => boolean for whether to include subex gene predictions
##  'verbose' => boolean for whether to output more information
## RETURNS: hash with process info keys: nseen, nskipped, nadded, nfailed
sub process_stream ($$) {
  my ($u,$in) = @_;
  my %rv = ( nseen => 0, nskipped => 0, nfailed => 0, nadded => 0, naliases => 0 );

  # build a hash of tax_ids in tax.spspec only load tax_id if found in this
  # hash.  hack to handle the fact that swissprot doesn't have all of the 
  # tax_ids in their schema.
  my %tax_id = map {$_->[0],1} @{$u->selectall_arrayref( 'select distinct tax_id from tax.spspec' )};

  while ( my $bs = $in->next_seq() ) {
	try {
	  process_seq($u,$bs,\%rv,\%tax_id);
	} catch Unison::Exception with {
	  warn($_[0]);
	};
  }
  return(\%rv);
}


## NAME: process_seq
## PURPOSE: parse Bio::Seq object and load seq and alia into Unison
## ARGUMENTS: Bio::Seq object, option hashref, process info hashref (keys:
##  nseen, nskipped, nadded), hashref of allowable tax_ids
## NOTES: sequences loaded into the "refseq" origin are loaded with sequence
##		version numbers; all others origins ignore sequence version, if any.
## RETURNS: nada
sub process_seq ($$$$) {
  my ($u,$bs,$rv,$tax_id_allowed) = @_;
  my ( %alias, %md5 );
  my $id = $bs->display_id();
  my $descr = $bs->desc();
  my $seq = clean_sequence( $bs->seq() );
  my $md5 = sequence_md5($seq);
  my @aliases = ();						  # aliases to be loaded for this sequence
  my $tax_id = 'NULL';

  (defined $seq)
	|| die("$id: sequence not defined");

  $rv->{nseen}++;

  # skip sequences in various conditions
  my $skip;
  if (not defined $id) {
    $skip = "sequence id isn't defined?!";
  } elsif ($id !~ m/\w/) {
    $skip = "doesn't look like a valid sequence id"; 
  } elsif (defined $opts{'start-after'}) {
    $skip = "haven't reached $opts{'start-after'} yet";
    undef $opts{'start-after'} if ($id eq $opts{'start-after'});
  } elsif (%alias and exists $alias{$id}) {
    $skip = 'extant alias';
  } elsif (length($seq) == 0) {
    $skip = "zero-length";
  } elsif (!$opts{'incl-subex'} and $descr =~ m%/type=(\w+)% and $1 ne 'gene') {
    $skip = "non-gene genescan transcript";
  }
  if (defined $skip) {
    warn("# skipping $id: $skip ($descr)\n") if $opts{verbose};
    $rv->{nskipped}++;
    return;
  }

  # prepare aliases and description text
  $descr = '' unless defined $descr;
  $descr =~ s/\s{2,}/ /g;
  $descr =~ s/^\s+//;
  $descr =~ s/\s+$//;
  $descr =~ s/\.$//;

  # see if there's species info and make sure that the tax_id is in the set of allowable
  # tax_ids (see description of process_stream method for more info).  if so, get the 
  # tax_id to insert with the # alias
  if (defined $bs->species && defined $bs->species->ncbi_taxid() && 
	  defined $tax_id_allowed->{$bs->species->ncbi_taxid()} ) {
    $tax_id = $bs->species->ncbi_taxid();
  }

  # origin-specific loading
  @aliases = ( $id );
  if (uc($opts{origin}) eq 'REFSEQ') {
	my $v = $bs->seq_version();
	if (defined $v) {
	  $id .= ".$v";
	  @aliases = ( $id );
	}
  } elsif ($opts{origin} =~ m/^Uniprot|Swiss-Prot/i) {
	# load S-P accession as well
  	push( @aliases, $bs->accession() );
  } elsif ($opts{origin} =~ m/GenenGenes/i) {
	$descr =~ s/\[(?:min|full)\]\s+//;
	$descr =~ s/\# converted.+//;
  } elsif ($opts{origin} =~ m/^TNF6F/i) {
	# this is a hack to remove extraneous comments from the tnf-filter
	# it should really be addressed there...
	$descr =~ s%/coords.+trans=[FR]\d %%;
	$tax_id = 9606;
  } else {
	# intentionally blank
  }


  # select/insert sequence to get a pseq_id
  my $pseq_id;
  my $frommd5='';
  if (%md5 and defined $md5{ $md5 }) {
    $pseq_id = $md5{ $md5 };
    $frommd5='*';
  } else {
	try {
	  $pseq_id = $u->pseq_si_pseq_id( $seq );
	} catch Unison::Exception with {
	  $rv->{nfailed}++;
	  warn("Failed to load sequence $aliases[0] ($descr)\n",
		   $_[0] );
	  return;
	};
    $md5{ $md5 } = $pseq_id;
	$rv->{nadded}++;
  }

  # load unique aliases for this pseq_id
  my %aliases = map {$_=>1} @aliases;
  foreach my $alias (keys %aliases)  {
	try {
	  $u->add_palias($pseq_id,$opts{porigin_id},$alias,$descr,$tax_id);
	} catch Unison::Exception with {
	  warn("Failed to load alias $alias for Unison:$pseq_id\n",
		   $_[0]);
	};
	$rv->{naliases}++;
  }

  printf(STDERR "## added pseq_id=$pseq_id$frommd5, len=%d, aliases={@aliases}, descr=%s\n",
		 length($seq), $descr) if $opts{verbose};

  return;
}

#! /usr/bin/env perl

my $usage = <<'EOU';
#-------------------------------------------------------------------------------
# NAME: load-pseq
# PURPOSE: load sequence files into Unison
# USAGE: load-pseq ARGUMENTS OPTIONS <seq files ...>
# ARGUMENTS (required):
#   --origin|-o <origin>: name of origin
#   --format|-f <format>: name of input file format (any format allowed by Bio::SeqIO)
# OPTIONS:
#   --start-after|--startafter <acc>: start parsing input file after this acc
#   --sql-only|--sqlonly: flag to output only sql commands
#   --incl-subex|--inclsubex: flag to include suboptimal gene predictions
#   --verbose|-v: flag to output more processing information
#
# $Id: load-pseq,v 1.8 2004/05/14 20:44:26 rkh Exp $
#------------------------------------------------------------------------------

EOU

use warnings;
use strict;
use Bio::SeqIO;
use Getopt::Long qw(:config gnu_getopt);
use Unison;
use Unison::utilities qw(clean_sequence);
use IO::Zlib;
use IO::File;
use Digest::MD5  qw(md5_hex);


sub tally ($%);
sub process_stream ($$);
sub process_seq ($$$$);


my %af = ( fthelper => 1,
		   multifile => 1, abi => 1, ace => 1, alf => 1,
		   asciitree => 1, bsml => 1, chadoxml => 1, ctf => 1,
		   embl => 1, exp => 1, fasta => 1, fastq => 1,
		   game => 1, gcg => 1, genbank => 1, kegg => 1,
		   largefasta => 1, locuslink => 1, metafasta => 1, phd => 1,
		   pir => 1, pln => 1, qual => 1, raw => 1,
		   scf => 1, swiss => 1, tab => 1, tigr => 1,
		   ztr => 1);
my %opts = (
			origin => undef,
			format => undef,
			'start-after' => undef,
			'sql-only' => 0,
			'include-subex' => 0,
			'verbose' => 0
);
GetOptions( \%opts,
			'origin|o=s',
			'format|f=s',
			'start-after|startafter|A=s',
			'sql-only|sqlonly',
			'verbose|v',
			'incl-subex|inclsubex' )
  || die("$0: bad usage:\n$usage\n");


(defined $opts{origin})
  || die("$0: --origin (-o) is mandatory\n$usage\n");
(defined $opts{format} && $af{lc($opts{format})})
  || die("$0: --format (-f) is mandatory and must be one of (",
		 join(',',sort {$a cmp $b} keys %af),")\n$usage\n");


my $u = new Unison;

$opts{porigin_id} = $u->porigin_porigin_id_by_origin($opts{origin});


my %totals = map { $_=>0 } qw(nseen nadded nskipped nfailed naliases);

foreach my $fn ( @ARGV ) {
  my $fh;
  if ($fn =~ m/\.gz$/) {
	die("Reading from gzipped files is currently broken. Sorry.\n");
	$fh = new IO::Zlib;
	$fh->open($fn,'rb')
	  || die("$fn: $!\n");
  } else {
	$fh = new IO::File;
	$fh->open($fn)
	  || die("$fn: $!\n");
  }

  my $stream = Bio::SeqIO->new(-fh => $fh, 
							   -format => $opts{format});
  my $stats = process_stream($u,$stream);
  print(STDERR tally($fn,%$stats), "\n");

  $totals{$_} += $stats->{$_} for keys %$stats;
  $fh->close();
}

print(STDERR tally('totals',%totals), "\n");

if ($totals{nfailed} > 0) {
  die("! WARNING: Some sequence and/or aliases failed; origin.last_updated NOT tickled\n");
}

if ($totals{nadded} > 0) {
  print( "update porigin set last_updated='",
		 $u->porigin_last_updated($opts{porigin_id},1),
		 "' where porigin_id=$opts{porigin_id}\n");
} else {
  warn("! WARNING: No sequences loaded; origin.last_updated NOT tickled\n");
}




###########################################################################
## INTERNALS

sub tally ($%) {
  my ($src,%stats) = @_;
  sprintf('%-30s %7d seen, %7d added, %7d skipped, %7d failed, %7d aliases',
		  (length($src)>29 ? '...'.substr($src,-26) : $src).':',
		  @stats{qw(nseen nadded nskipped nfailed naliases)});
}



## NAME: process_stream
## PURPOSE: parse Bio::SeqIO stream and load sequences into Unison
## ARGUMENTS: Bio::SeqIO object, option hashref:
##'origin' => name of porigin (REQUIRED)
##  'start-after' => skip seqs until this accession
##  'sql-only' => boolean for sql output only (no loading in Unison)
##  'incl-subex' => boolean for whether to include subex gene predictions
##  'verbose' => boolean for whether to output more information
## RETURNS: hash with process info keys: nseen, nskipped, nadded, nfailed
sub process_stream ($$) {
  my ($u,$in) = @_;
  my %rv = ( nseen => 0, nskipped => 0, nfailed => 0, nadded => 0, naliases => 0 );

  # build a hash of tax_ids in tax.spspec only load tax_id if found in this
  # hash.  hack to handle the fact that swissprot doesn't have all of the 
  # tax_ids in their schema.
  my %tax_id = map {$_->[0],1} @{$u->selectall_arrayref( 'select distinct tax_id from tax.spspec' )};

  while ( my $bs = $in->next_seq() ) {
	try {
	  process_seq($u,$bs,\%rv,\%tax_id);
	} catch Unison::Exception with {
	  warn($_[0]);
	};
  }
  return(\%rv);
}


## NAME: process_seq
## PURPOSE: parse Bio::Seq object and load seq and alia into Unison
## ARGUMENTS: Bio::Seq object, option hashref, process info hashref (keys:
##  nseen, nskipped, nadded), hashref of allowable tax_ids
## NOTES: sequences loaded into the "refseq" origin are loaded with sequence
##		version numbers; all others origins ignore sequence version, if any.
## RETURNS: nada
sub process_seq ($$$$) {
  my ($u,$bs,$rv,$tax_id_allowed) = @_;
  my ( %alias, %md5 );
  my $id = $bs->display_id();
  my $seq = $bs->seq();

  (defined $seq)
	|| throw Unison::Exception::RuntimeError("$id: sequence not defined");

  my $tax_id;
  my $descr = $bs->desc();
  $seq = clean_sequence($seq);
  my $md5 = &md5_hex($seq);
  $rv->{nseen}++;

  # description reformatting
  $descr = '' unless defined $descr;
  $descr =~ s/\s{2,}/ /g;
  $descr =~ s/^\s+//;
  $descr =~ s/\s+$//;

  if ($opts{origin} =~ m/spdi/i) {
	$descr =~ s/\[(?:min|full)\]\s+//;
	$descr =~ s/\# converted.+//;
  } elsif ($opts{origin} =~ m/refseq/i) {
	my $v = $bs->seq_version();
	if (defined $v) {
	  $id .= ".$v";
	}
  }

  # skip sequences in various conditions
  my $skip;
  if ($id !~ m/\w/) {
    $skip = "doesn't look like a valid sequence id"; 
  } elsif (defined $opts{'start-after'}) {
    $skip = "haven't reached $opts{'start-after'} yet";
    undef $opts{'start-after'} if ($id eq $opts{'start-after'});
  } elsif (%alias and exists $alias{$id}) {
    $skip = 'extant alias';
  } elsif (length($seq) == 0) {
    $skip = "zero-length";
  } elsif (!$opts{'incl-subex'} and $descr =~ m%/type=(\w+)% and $1 ne 'gene') {
    $skip = "non-gene genescan transcript";
  }
  if (defined $skip) {
    warn("# skipping $id: $skip ($descr)\n") if $opts{verbose};
    $rv->{nskipped}++;
    return;
  }

  # @ids is the SET of ids to which we'll link this sequence
  my @ids = ();

  if ($opts{origin} =~ m/SPDI/i) {
    my %ids;
    $ids{$1}++ if $descr =~ s/(PRO\d+)\s+//;
    # Don't put UNQs or DNAs in database -- unqs aren't unique and dnas
    # are proteins
	# $ids{$1}++ if $descr =~ s/(UNQ\d+)\s+//;
    # $ids{$1}++ if $descr =~ s/(DNA\d+)\s+//;
    # $ids{$id}++;
    @ids = sort keys %ids;
  } else {
    @ids = ( $id );
  }

  if ($opts{'sql-only'}) {
    printf("insert into pseq (seq,len) values ('$seq',%d);\n",
		   length($seq)); return 1;
  }

  # select/insert sequences, then link aliases
  my $pseq_id;
  my $frommd5='';
  if (%md5 and defined $md5{ $md5 }) {
    $pseq_id = $md5{ $md5 };
    $frommd5='*';
  } else {
	try {
	  $pseq_id = $u->pseq_si_pseq_id( $seq );
	} catch Unison::Exception with {
	  my $ex = shift;
	  $rv->{nfailed}++;
	  throw Unison::Exception::RuntimeError( "Failed to load sequence $ids[0] ($descr)",
											 $ex );
	};
    $md5{ $md5 } = $pseq_id;
	$rv->{nadded}++;
  }


  # see if there's species info and make sure that the tax_id is in the set of allowable
  # tax_ids (see description of process_stream method for more info).  if so, get the 
  # tax_id to insert with the # alias
  if (defined $bs->species && defined $bs->species->ncbi_taxid() && 
	  defined $tax_id_allowed->{$bs->species->ncbi_taxid()} ) {
    $tax_id = $bs->species->ncbi_taxid();
  } else {
    $tax_id = 'NULL';
  }

  foreach my $upd_id (@ids)  {
	try {
	  $u->add_palias($pseq_id,$opts{porigin_id},$upd_id,$descr,$tax_id);
	} catch Unison::Exception with {
	  $rv->{nfailed}++;
	  throw Unison::Exception::RuntimeError( "Failed to load one or more aliases for $pseq_id",
											 $_[0] );
	};
	$rv->{naliases}++;
  }

  printf(STDERR "## added pseq_id=$pseq_id$frommd5, len=%d, aliases={@ids}, descr=%s\n",
		 length($seq), $descr) if $opts{verbose};

  return;
}

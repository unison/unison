#! /usr/bin/env perl

my $usage = <<'EOU';
#-------------------------------------------------------------------------------
# NAME: load-pseq
# PURPOSE: load sequence files into Unison
# USAGE: load-pseq ARGUMENTS OPTIONS <seq files ...>
# ARGUMENTS (required):
#   --origin|-o <origin>: name of origin
#   --format|-f <format>: name of input file format (any format allowed by Bio::SeqIO)
# OPTIONS:
#   --start-after|--startafter <acc>: start parsing input file after this acc
#   --sql-only|--sqlonly: flag to output only sql commands
#   --incl-subex|--inclsubex: flag to include suboptimal gene predictions
#   --verbose|-v: flag to output more processing information
#
# $Id: load-pseq,v 1.5 2004/04/21 20:06:59 rkh Exp $
#------------------------------------------------------------------------------

EOU

use warnings;
use strict;
use Bio::SeqIO;
use Getopt::Long qw(:config gnu_getopt);
use Unison;
use IO::Zlib;

sub tally ($%);


my %af = ( fthelper => 1,
		   multifile => 1, abi => 1, ace => 1, alf => 1,
		   asciitree => 1, bsml => 1, chadoxml => 1, ctf => 1,
		   embl => 1, exp => 1, fasta => 1, fastq => 1,
		   game => 1, gcg => 1, genbank => 1, kegg => 1,
		   largefasta => 1, locuslink => 1, metafasta => 1, phd => 1,
		   pir => 1, pln => 1, qual => 1, raw => 1,
		   scf => 1, swiss => 1, tab => 1, tigr => 1,
		   ztr => 1);
my %opts = (
			origin => undef,
			format => undef,
			'start-after' => undef,
			'sql-only' => 0,
			'include-subex' => 0,
			'verbose' => 0
);
GetOptions( \%opts,
			'origin|o=s',
			'format|f=s',
			'start-after|startafter|A=s',
			'sql-only|sqlonly',
			'verbose|v',
			'incl-subex|inclsubex' )
  || die("$0: bad usage:\n$usage\n");


(defined $opts{origin})
  || die("$0: --origin (-o) is mandatory\n$usage\n");
(defined $opts{format} && $af{lc($opts{format})})
  || die("$0: --format (-f) is mandatory and must be one of (",
		 join(',',sort {$a cmp $b} keys %af),")\n$usage\n");




my $u = new Unison;
my $fh = new IO::Zlib;
my %totals;

foreach my $fn ( @ARGV ) {
  $fh->open($fn, 'rb')
	|| die("$fn: $!\n");
  my $stream = Bio::SeqIO->new(-fh => $fh, 
							   -format => $opts{format});
  my $stats = $u->process_stream($stream, \%opts);
  print(STDERR tally($fn,%$stats), "\n");

  $totals{$_} += $stats->{$_} for keys %$stats;
  $fh->close();
}

print(STDERR tally('totals',%totals), "\n");

$opts{porigin_id} = $u->porigin_porigin_id_by_origin($opts{origin});
print( "update porigin set last_updated='",
	   $u->porigin_last_updated($opts{porigin_id},1),
	   "' where porigin_id=$opts{porigin_id}\n");




sub tally ($%) {
  my ($src,%stats) = @_;
  sprintf('%-30s %7d seen, %7d added, %7d skipped, %7d failed, %7d aliases',
		  (length($src)>29 ? '...'.substr($src,-26) : $src).':',
		  @stats{qw(nseen nadded nskipped nfailed naliases)});
}

#!/usr/bin/env perl

my $usage = <<'EOU';
#-------------------------------------------------------------------------------
# NAME: load-pseq
# PURPOSE: load sequence files into Unison
# USAGE: load-pseq ARGUMENTS OPTIONS <seq files ...>
# ARGUMENTS (required):
#   --origin|-o <origin>: name of origin
#   --format|-f <format>: name of input file format (any format allowed by Bio::SeqIO)
# OPTIONS:
#   --start-after|--startafter <acc>: start parsing input file after this acc
#   --incl-subex|--inclsubex: flag to include suboptimal gene predictions
#   --verbose|-v: flag to output more processing information
#
# $Id: load-pseq,v 1.24 2006/03/14 01:26:25 rkh Exp $
#------------------------------------------------------------------------------

EOU

use warnings;
use strict;
use Bio::SeqIO;
use Getopt::Long qw(:config gnu_getopt);
use Unison;
use Unison::Exceptions;
use Unison::Utilities::misc qw(clean_sequence sequence_md5);
use IO::File;
use Benchmark ':hireswallclock';
use Data::Dumper;


sub tally ($%);
sub process_stream ($$);
sub process_seq ($$$);


# acceptable file formats (subset of Bioperl)
my @af = qw(embl fasta fastq genbank locuslink phd pir swiss);
my %af = map { $_=>1 } @af;


my %opts = (
			origin => undef,
			format => undef,
			'verbose' => 0,
			tax_id => undef,
			'allow-anonymous-sequences' => 0,
			'infer-tax-id' => 0,
			'dry-run' => 0
);
GetOptions( \%opts,
			'origin|o=s',
			'format|f=s',
			'verbose|v+',
			'tax_id|t=i',
			'allow-anonymous-sequences+',
			'infer-tax-id+',
			'dry-run|n+',
		  )
  || die("$0: bad usage:\n$usage\n");


(defined $opts{origin})
  || die("$0: --origin (-o) is mandatory\n$usage\n");
(defined $opts{format} && $af{lc($opts{format})})
  || die("$0: --format (-f) is mandatory and must be one of (",
		 join(',',sort {$a cmp $b} keys %af),")\n$usage\n");


my $u = new Unison( dbname=>'csb-dev', username=>'loader' );

my %origin_to_porigin_id = map {$_->[0] => $_->[1]}
  @{$u->selectall_arrayref( 'select origin,porigin_id from porigin' )};
$opts{porigin_id} = $origin_to_porigin_id{$opts{origin}};
(defined $opts{porigin_id})
  || die("$0: origin $opts{origin} doesn't exist\n");

my %latin_to_tax_id = map  {$_->[0] => $_->[1]}
  @{$u->selectall_arrayref( 'select lower(latin),tax_id from tax.spspec' )};
my %gs_to_tax_id = map  {$_->[0] => $_->[1]}
  @{$u->selectall_arrayref( 'select upper(gs),tax_id from tax.spspec' )};
my %known_tax_ids = map {$_ => 1} values %latin_to_tax_id;

(defined $opts{tax_id} and defined $opts{'infer-tax-id'})
  && die("$0: you may not specify a tax_id and request infer-tax-id\n");

(defined $opts{tax_id} and not exists $known_tax_ids{$opts{tax_id}})
  && die("$0: you specified an invalid tax_id\n");

($opts{origin} =~ m/^RefSeq/ and $opts{format} !~ m/genbank/i)
  && die("$0: $opts{origin} sequences should be loaded from genbank format files\n");

($opts{origin} =~ m/^UniProt/ and $opts{format} !~ m/sprot/i)
  && die("$0: $opts{origin} sequences should be loaded from sprot format files\n");



my %warnings;					  # hash of warnings to prevent duplicates
my @tally_bins = qw(nseen nadded nskipped nfailed naliases);
my %totals = map { $_=>0 } @tally_bins;
my $tts = new Benchmark;


foreach my $fn ( @ARGV ) {
  my $fh;
  $fh = new IO::File;
  $fh->open($fn)
	|| die("$fn: $!\n");

  my $stream = Bio::SeqIO->new(-fh => $fh, 
							   -format => $opts{format});
  my $tis = new Benchmark;
  my $stats = process_stream($u,$stream);
  my $tie = new Benchmark;
  my $tidelta = @{timediff($tie, $tis)}[0];
  print(STDERR tally($fn,$tidelta,%$stats), "\n");

  $totals{$_} += $stats->{$_} for @tally_bins;
  $fh->close();
}

my $tte = new Benchmark;
my $ttdelta = @{timediff($tte, $tts)}[0];
print(STDERR tally('totals',$ttdelta,%totals), "\n");

if ($totals{nfailed} > 0) {
  die("! WARNING: Some sequence and/or aliases failed; origin.last_updated NOT tickled\n");
}

if ($totals{nadded} > 0 and not $opts{'dry-run'}) {
  print( "update porigin set last_updated='",
		 $u->porigin_last_updated($opts{porigin_id},1),
		 "' where porigin_id=$opts{porigin_id}\n");
} else {
  warn("! WARNING: No sequences loaded; origin.last_updated NOT tickled\n");
}

exit(0);





###########################################################################
## INTERNALS

## NAME: process_stream
## PURPOSE: parse Bio::SeqIO stream and load sequences into Unison
## ARGUMENTS: Bio::SeqIO object, option hashref:
##'origin' => name of porigin (REQUIRED)
##  'verbose' => boolean for whether to output more information
## RETURNS: hash with process info keys: nseen, nskipped, nadded, nfailed
sub process_stream ($$) {
  my ($u,$in) = @_;
  my %stats = map {$_=>0} @tally_bins;
  while ( my $bs = $in->next_seq() ) {
	try {
	  process_seq($u,$bs,\%stats);
	} catch Unison::Exception with {
	  warn($_[0]);
	};
  }
  return(\%stats);
}


## NAME: process_seq
## PURPOSE: parse Bio::Seq object and load seq and alia into Unison
## ARGUMENTS: Bio::Seq object, option hashref, process info hashref (keys:
##  nseen, nskipped, nadded), hashref of allowable tax_ids
## NOTES: sequences loaded into the "refseq" origin are loaded with sequence
##		version numbers; all others origins ignore sequence version, if any.
## RETURNS: nada
sub process_seq ($$$) {
  my ($u,$bs,$stats) = @_;

  my %md5;
  my $pseq_id;
  my $frommd5;
  my @anno = ();				 # @ of [porigin_id, alias, descr]

  my $seq = clean_sequence( $bs->seq() );
  my $md5 = sequence_md5($seq);
  my $id = $bs->display_id();
  my $descr = $bs->desc();
  my $tax_id = ( (defined $bs->species and defined $bs->species->ncbi_taxid())
				 ? $bs->species->ncbi_taxid()
				 : $opts{tax_id} );

  $stats->{nseen}++;

  # attend to some of the vagaries of human curation and folly...
  $descr = '' unless defined $descr;
  $descr =~ s/\02//g;						# remove ^B (some Proteome)
  $descr =~ s/\s{2,}/ /gm;					# including \s\n\s
  $descr =~ s/(\S)\n(\S)/$1$2/;				# newline amid non-whitespace


  # split ctrl-A delimited entries into explict entries for this sequence
  # this is effectively a no-op for single-entry deflines.  It's necessary to
  # deal with NCBI fasta files which contain collect non-redundant annotations into
  # one defline.  Also try to infer the tax_id from the descr
  foreach my $ad ( split(/\01/, "$id $descr") ) {
	my ($a,$d) = $ad =~ m/^(\S+)\s+(.*)/g;
	(defined $a and defined $d)
	  || die("couldn't parse alias and/or descr from '$ad'\n");
	push(@anno, [$opts{origin},$a,$d,$tax_id]);
  }


  # add tax_ids and origin-specific processing of @anno
  my @secondary_anno = ();
  for ( my $i=0; $i<=$#anno; $i++ ) {
	my ($o,$a,$d,$t) = @{$anno[$i]};

	# infer tax from descr [<latin>] at the end of an annotation I don't
	# enable this by default because I'm concerned about descriptions like
	# 'ortholog of hsp70 [homo sapiens]' for a non- human sequence.
	if ( $opts{'infer-tax-id'}
		 and my ($latin) = $d =~ m/\[([^\]]+)\]\W*$/ ) {
	  $latin = lc($latin);
	  if (defined $latin_to_tax_id{$latin}) {
		$t = $latin_to_tax_id{$latin};
		if (defined $tax_id and $t != $tax_id) {
		  warn("! Unison:$pseq_id: changed tax_id from $tax_id to $t ($latin)\n");
		}
	  } else {
		$warnings{'unknown latin species'}{$latin}++
		  || warn("! no species found for $latin\n");
	  }
	}

	if ( $o =~ m/^RefSeq/i ) {
	  if ($opts{format} =~ m/genbank/i) {
		push( @secondary_anno, [ "$o gi", $bs->primary_id(), $d, $t ] );
	  } elsif ( $a =~ m/^gi\|(\d+)/ ) {
		push( @secondary_anno, [ "$o gi", $1, $d, $t ] );
	  }
	  $a =~ s/^.*ref\|([^\|]+).*/$1/;		# refseq alias only
	  (defined $a)
		|| die("! Unison:$pseq_id ($id) doesn't contain a RefSeq accession!\n");

	} elsif ( $o =~ m/^(?:pataa)/i ) {
	  # the accession mess in pataa deflines isn't necessarily unique.  E.g.,
	  # Unison:1795309, len=11, 2 annotations
	  #    + pataa:gi|998068|gb|AAA76369.1| Sequence 32 from patent US 5451499 [NULL]
	  #    + pataa:gi|998068|gb|AAA76369.1| Sequence 13 from patent US 5451499 [NULL]
	  # So, we'll uniquify it with meaningful text from the descr
	  if ($d =~ m/^Sequence (\d+) from Patent (.+)/) {
		my $PSn = "$2#$1";
		$PSn =~ s/\s+//g;
		$a .= "|$PSn";
	  }

	} elsif ($o =~ m/^Uniprot|Swiss-Prot/i) {
	  if (not defined $t) {
		my ($gs) = $a =~ m/_(\w+)/;
		if (defined $gs) {
		  my $newt = $gs_to_tax_id{uc($gs)};
		}
	  }
	  push(@anno, [$o,$bs->accession(),$d,$t] );

	} elsif ($o =~ m/^CCDS/i) {
	  $d = $a;
	  ($a) = $d =~ m/^([^|]+)/;

	} elsif ($o =~ m/GenenGenes/i) {
	  $d =~ s/\[(?:min|full)\]\s+//;
	  $d =~ s/\# converted.+//;

	} elsif ($o =~ m/^TNF6F/i) {
	  $d =~ s%/coords.+trans=[FR]\d %%;
	}

	$anno[$i] = [$o,$a,$d,$t];
  }

  if ($#anno == -1 and not $opts{'allow-anonymous-sequences'}) {
	die("Unison:$pseq_id has no primary annotations and allow-anonymous-sequences is not set\n",
		"id=$id; descr=$descr\n")
  }

  push(@anno, @secondary_anno);


  # select/insert sequence to get a pseq_id or get it by md5 hash from
  # identical sequences already inserted in this session
  if (%md5 and defined $md5{ $md5 }) {
    $frommd5 = '*';
    $pseq_id = $md5{ $md5 };
  } else {
	$frommd5 = '';
	try {
	  $pseq_id = $opts{'dry-run'} ? 0 : $u->pseq_si_pseq_id( $seq );
	  $md5{ $md5 } = $pseq_id;
	  $stats->{nadded}++;
	} catch Unison::Exception with {
	  $stats->{nfailed}++;
	  warn("! Failed to load sequence $id ($descr)\n", $_[0]);
	  return;
	};
  }
  printf(STDERR "* Unison:$pseq_id$frommd5, len=%d, %d annotations\n",
		 length($seq), $#anno+1) if $opts{verbose};


  # load [o,a,d,t] triplets for this pseq_id
  foreach my $anno (@anno)  {
	my ($o,$a,$d,$t) = @$anno;

	if ($a =~ m/\|/ and not $warnings{alias_pipe}++) {
	  warn("! You're loading aliases with `|' (e.g., `$a')\n");
	}

	my $o_id = $origin_to_porigin_id{$o};
	(defined $o_id)
	  || die("$0: couln't find origin $o\n");

	# Sequences are tagged with the tax_id only if the tax_id is found in
	# known_tax_ids.  This is necessary to handle discrepancies.
	if (defined $t and not exists $known_tax_ids{$t}) {
	  $warnings{'missing tax_id'}{$t}++
		|| warn("! tax_id=$t not defined in Unison\n");
	  undef $t;
	}
	$t = 'NULL' unless defined $t;

	try {
	  $u->add_palias($pseq_id,$o_id,$a,$d,$t) unless $opts{'dry-run'};
	} catch Unison::Exception with {
	  warn("! Failed to load alias $a for Unison:$pseq_id\n",$_[0]);
	};
	printf(STDERR "   + $o:$a $d [$t]\n") if $opts{verbose}>1;
	$stats->{naliases}++;
  }

  return;
}


sub tally ($%) {
  my ($src,$delta,%stats) = @_;
  sprintf('%-30s %7d seen, %7d added, %7d skipped, %7d failed, %7d aliases, %8ds, %5.1f seen/s',
		  (length($src)>29 ? '...'.substr($src,-26) : $src).':',
		  @stats{qw(nseen nadded nskipped nfailed naliases)},
		  $delta,
		  $stats{nseen} / $delta
		 );
}



##  # split ctrl-A delimited entries into explict entries for this sequence
##  # this is effectively a no-op for single-entry deflines
##  foreach my $ad ( split(/\01/, "$id $descr") ) {
##	my ($a,$d) = $ad =~ m/^(\S+)\s+(.*)/g;
##	if (not defined $a or not defined $d) {
##	  die("couldn't parse alias and descr from '$ad'\n");
##	}
##	$d =~ s/^\s+|\s+$|\.$//;
##	my $t = $tax_id;						# default or from $bs->speciees
##	# infer tax_id from descr
##	if (my ($latin) = $d =~ m/\[([^\]]+)\]/) {
##	  if (exists $latin_to_tax_id{$latin}) {
##		$t = $latin_to_tax_id{$latin};
##	  } else {
##		$warnings{'unknown latin species'}{$latin}++
##		  || warn("no species found for $latin\n");
##	  }
##	  push(@anno, [$a,$d,$t]);
##	}
##  }



#!/usr/bin/env perl

#-------------------------------------------------------------------------------
# run-tmdetect -- run and insert tmdetect into Unison
# arguments: 
#   --params_id|-p <params_id>: params_id for loading (required)
#   --tfile|-t <template file>: file containing a list of templates (optional)
#   --update: force update (i.e. delete cooresponding rows in unison before inserting) (optional)
# usage: run-tmdetect [psql options] --params_id <params_id> [--tfile <template file>] [--update]
#
# $Id: run-tmdetect,v 1.5 2004/05/14 20:52:57 rkh Exp $
#-------------------------------------------------------------------------------

use warnings;
use strict;

use File::Temp;
use Unison;
use Unison::SQL;
use Bio::Seq;
use Bio::SeqIO;
use Bio::Prospect::Options;
use Bio::Prospect::Exceptions;
use Getopt::Long qw(:config gnu_getopt);
use Data::Dumper;
use Error qw(:try);

my %opts = (
			'debug' => 0,
			'params_id' => 9,
			'pmodelset_id' => undef,
			'porigin_id' => undef,
			'update' => 0,          # try update before insert
			'verbose' => 0,
		   );
GetOptions(\%opts,
       'debug+',
       'params_id=i',
       'update',
       'verbose!',
      )
  or die("$0: bad usage\n");


(defined $opts{params_id})
  || die( "$0: --params_id|-p parameter missing\n" );


if ($opts{debug}) {
  select STDERR; $|++;
  select STDOUT; $|++;
  print Dumper(\%opts);
}

my $u = new Unison;

my $args = $u->run_commandline_by_params_id( $opts{params_id});
my %run_me;  #pseqs to tmdetect

my (@pseq_ids) = @ARGV ? map {eval "$_"} @ARGV : map { chomp;$_ } <>;

# get temp files for sequences to be tmdetect'd and
# the tmdetect output
my ($fa_fh,  $fa_fn)  = File::Temp::tempfile( UNLINK => 1, SUFFIX => '.fa' );
my ($out_fh, $out_fn) = File::Temp::tempfile( UNLINK => 1, SUFFIX => '.out' );

# get pftype_ids for tmdetect output types (i.e. signal, N-TM, M-TM)
my $tmds_id = &get_pftype_id( $u, 'tmdetect/signal' );
my $tmdm_id = &get_pftype_id( $u, 'tmdetect/M (in->out)' );
my $tmdn_id = &get_pftype_id( $u, 'tmdetect/N (out->in)' );
die( "Can't retrieve all of the pftype_ids for tmdetect" ) if 
  ( ! ( defined $tmds_id && defined $tmdm_id && defined $tmdn_id ) ); 

# output FASTA file with pseqs that need to be
# tmdetect'd
my $seqio = new Bio::SeqIO( -fh => $fa_fh,
							-format => 'Fasta' );

PSEQ_ID:
while( my $pseq_id = shift(@pseq_ids) ) {
  my $leader = "\rUnison:$pseq_id";
  print(STDERR $leader);

  my $ran_on = $u->get_run_timestamp($pseq_id,$opts{params_id},undef,undef);
  if (defined $ran_on and not $opts{update}) {
    print(STDERR "$leader: run with these options on $ran_on; skipping\n");
    next PSEQ_ID;
  }

  my $seq = $u->get_sequence_by_pseq_id( $pseq_id );
  $leader .= " (" . length($seq) . " AA)";

#  print("$leader: outputted for tmdetect\n");
  $seqio->write_seq(new Bio::Seq(-id=>"Unison:$pseq_id",-seq=>$seq));

  $run_me{ $pseq_id }++;
}
$seqio->close();


# run tmdetect (only if we have seqs to tmdetect) and parse results
if ( scalar(keys %run_me) > 0 ) {
  my $cmd = "tmdetect $args $fa_fn > $out_fn";
  system($cmd);
  print STDERR "exec'n: $cmd\n" if $opts{verbose};

  #Unison:291 1 (S) 7 0 17 0.999933
  my $sql = 'insert into pftmdetect (pseq_id,pftype_id,start,stop,confidence,params_id) '.
    'values (?,?,?,?,?,?)';
  (my $sqlf = $sql) =~ s/\?/%s/g;
  my $sth = $u->prepare( $sql );
  open(FP,$out_fn) or die("can't open $out_fn for parsing tmdetect results");
  while(<FP>) {
    my @tmd = split;

    my $pft;
    if ( $tmd[2] eq '(S)' ) { 
      $pft = $tmds_id;
    } elsif ( $tmd[2] eq '(M)' ) {
      $pft = $tmdm_id;
    } elsif ( $tmd[2] eq '(N)' ) {
      $pft = $tmdn_id;
    } else {
        die("Don't understand $tmd[2] feature type");
    }
    my $b = $tmd[3]-10 < 1 ? 1 : $tmd[3]-10;
    $tmd[0] =~ m/^Unison:(\d+)$/;
    my $pseq_id = $1;
    printf("$sqlf\n",$pseq_id, $pft, $b, $tmd[3]+10, $tmd[6],$opts{params_id});
	try {
	  $sth->execute( $pseq_id, $pft, $b, $tmd[3]+10, $tmd[6],$opts{params_id});
	} catch Unison::Exception with {
	  warn($_[0]);
	};

    # delete this pseq_id from the run_me hash and then update
    # the run history table.  any pseqs left in %run_me are pseqs
    # that tmdetect was run on but had no results.  we'll update
    # the run_history table below for those fellas.
    delete $run_me{ $pseq_id };
    $u->upd_run_history($pseq_id,$opts{params_id},undef,undef);
  }
}
  
# update run history for the seqs that were tmdetected but had no results
# (the above block of code parses the tmdetect results and updates the 
# run history for those seqs with results).
foreach my $pseq_id ( keys %run_me ) {
  $u->upd_run_history($pseq_id,$opts{params_id},undef,undef);
}

#-------------------------------------------------------------------------------
# NAME: get_pftype_id
# PURPOSE: retrieve a pftype_id for a given name
#-------------------------------------------------------------------------------

sub get_pftype_id {
  my ($u,$name) = @_;
  my $sql = "select pftype_id from pftype where name='$name'";
  print STDERR "get_pftype_id(), sql=[$sql]\n" if $opts{verbose};
  my $ary_ref = $u->selectall_arrayref( $sql );
  return( $ary_ref->[0][0] );
}

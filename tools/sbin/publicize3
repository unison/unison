#!/usr/bin/perl

warn(<<EOT);
Update the pgutils.foreign_keys view that has the null column
only use left join when the fk is nullable
EOT

use strict;
use warnings;

use DBI;
use Data::Dumper;
use File::Temp qw(tempdir);
use Getopt::Long qw(:config gnu_compat);
use IO::File;
use IO::Pipe;
use IPC::Open2;
use POSIX qw(strftime);
use Time::HiRes qw(gettimeofday tv_interval);

use FindBin;
use lib "$FindBin::RealBin/../../perl5";

use Unison;
use Unison::Schema::Table;

sub get_dump_toc($);
sub get_schema_dump($$);
sub get_table_info($);
sub get_table_info($);
sub restore_subset($$);


my $CVSId = q$Id: publicize3,v 1.1 2007/04/17 00:50:43 rkh Exp $; 
my @PHASE1_KW = qw(AGGREGATE FUNCTION PROCEDURAL SCHEMA SEQUENCE TABLE TYPE VIEW);
my $TERM_STRING = '__END_OF_COPY__';
my $VERBOSE_FREQ = 25000;
my %IGNORE_SCHEMAS = map {$_=>1} qw( mukhyala rkh matthejb twu cavs );
my %IGNORE_TABLES = map {$_=>1} qw( unison.p2gblataln unison.p2gblatalnhsp unison.p2gblathsp
		unison.paprospect );
my %table_predicates =
  (
   'unison.origin'	=> [ '$T.is_public = TRUE' ],
   'unison.params'	=> [ '$T.is_public = TRUE' ],
#   'unison.pseq' 	=> [ '$T.pseq_id < 1000'   ],
  );




select(STDERR); $|++;
select(STDOUT); $|++;

my $phase1_re = join('|',@PHASE1_KW);
my $tmp_dir = tempdir( '/tmp/Unison-publicize-XXXXX', CLEANUP => 1 );
my $dump_fn = "$tmp_dir/pgdump";
my $all_start = [gettimeofday];

my $src_db;
defined ($src_db = shift)
  || die("$0: missing source database name\n");

print(STDERR 
	  "# $0\n",
	  "# $CVSId\n",
	  "# started: ", strftime("%F %T %Z",localtime()), "\n"
	 );


get_schema_dump($src_db,$dump_fn);			# dies on error

my @toc = get_dump_toc($dump_fn);			# dies on error
printf(STDERR "%d TOC entries\n", $#toc+1);

print("-- PHASE 1: SCHEMA\n");
restore_subset( $dump_fn, [grep { m/\s(?:$phase1_re)\s/ } @toc] );

my %tables = get_table_info( new Unison(dbname => $src_db) );
# apply configuration predicates to the tables
foreach my $st (sort keys %table_predicates) {
  $tables{$st} = Unison::Schema::Table->new( 'st' => $st ) unless exists $tables{$st};
  for(my $i=0; $i<=$#{$table_predicates{$st}}; $i++) {
	$tables{$st}->add_pred( $table_predicates{$st}->[$i] );
  }
}

print("-- PHASE 2: DATA\n");
my ($src_psql_w,$src_psql_r);
my $src_psql_pid = open2($src_psql_r,$src_psql_w,'psql', '-d', $src_db);
my @table_tocs = grep { m/^\d+; \d+ \d+ TABLE / } @toc;

for(my $i=0; $i<=$#table_tocs; $i++) {
  my $table_start = [gettimeofday];

  my ($schema,$table) = $table_tocs[$i] =~ m/^\d+; \d+ \d+ TABLE (\S+) (\S+)/;
  my $st = "$schema.$table";

  my $pfx = sprintf("* %3d/%3d %-30s", $i+1, $#table_tocs+1, "$st: ");

  if (exists $IGNORE_SCHEMAS{$schema}) {
	printf(STDERR "$pfx   %15s\n", 'schema skipped');
	next;
  }

  if (exists $IGNORE_TABLES{$st}) {
	printf(STDERR "$pfx   %15s\n", 'table skipped');
	next;
  }

  my $cq = ( (exists $tables{$st})
			 ? $tables{$st}->copy_query(\%tables)
			 : "SELECT * FROM $st" );

  my $cqc = $cq; $cqc =~ s/^/--   /mg;
  print(STDERR "-- COPY QUERY FOR $st\n$cqc\n");
  print("-- COPY QUERY FOR $st\n$cqc\n");

  print(STDERR "$pfx  (querying)\r") if (-t 2);
  print("COPY $st FROM STDIN;\n");
  $src_psql_w->print("COPY ($cq) TO STDOUT;\n");
  $src_psql_w->print("\\echo $TERM_STRING\n");
  my $nrows = 0;
  while (my $line = <$src_psql_r>) {
	if ($line =~ m/^ERROR:/) {
	  die("Oh, man, are you in trouble.\n$line\n");
	}
	if ($line =~ m/^$TERM_STRING/) {
	  print("\\.\n");
	  last;
	}
	print($line);
	$nrows++;
	printf(STDERR "$pfx %15s\r","$nrows rows") if (-t 2 and $nrows % $VERBOSE_FREQ == 0);
  }
  printf(STDERR "$pfx %15s (%d s)\n",
		 "$nrows rows",tv_interval($table_start));
}
$src_psql_w->print("\\q\n");
print(STDERR "waiting for src psql pipe process to die [pid=$src_psql_pid]\n");
waitpid($src_psql_pid,0);
print(STDERR "# src psql process finished\n");


print("-- PHASE 3: INDEXES AND CONSTRAINTS\n");
restore_subset( $dump_fn, [grep { not m/\s(?:$phase1_re)\s/ } @toc] );

# !! comment, search_path, analyze

print(STDERR "# $0\n",
	  '# ended: ', strftime("%F %T %Z",localtime()),
	  ' (', sprintf("%.1f",tv_interval($all_start)/60/60), " h elapsed)\n");

exit(0);



## ######################################################################
## INTERNALS

sub get_table_info($) {
  my ($u) = @_;
  my %tables;
  my $sth = $u->prepare( q(
				  			SELECT fk_namespace,fk_relation,fk_column,
								   pk_namespace,pk_relation,pk_column,ud
							FROM pgutils.foreign_keys
				            ) );
  $sth->execute();
  my $nfks;
  while( my $row = $sth->fetchrow_hashref() ) {
	$nfks++;

	my $pkst = "$row->{pk_namespace}.$row->{pk_relation}";
	$tables{$pkst} = Unison::Schema::Table->new( 'st' => $pkst ) unless exists $tables{$pkst};

	my $fkst = "$row->{fk_namespace}.$row->{fk_relation}";
	$tables{$fkst} = Unison::Schema::Table->new( 'st' => $fkst ) unless exists $tables{$fkst};

	my %fk_data = ( (map { $_ => $row->{$_} } qw(fk_column pk_namespace pk_relation pk_column ud)), 
					pkt => $tables{pkst} );
	$tables{$fkst}->add_fk( \%fk_data );
  }
  $sth->finish();
  printf(STDERR "# %d FKs in %d tables\n", $nfks, scalar keys %tables);
  return %tables;
}

sub get_schema_dump($$) {
  my ($db,$fn) = @_;
  my @cmd = ('pg_dump', '-Fc', '-s', '-f', $fn, $db);
  system(@cmd)
	&& die("@cmd: $!\n");
}

sub get_dump_toc($) {
  my $fn = shift;
  my $io = new IO::Pipe;
  my @cmd = ('pg_restore', '-l', $fn);
  $io->reader(@cmd)
	|| die("@cmd: $!\n");
  return grep { not /^;/ } <$io>;
}

sub restore_subset($$) {
  my ($dump_fn,$toc_aref) = @_;
  my $toc_fn = "$tmp_dir/toc";

  my $toc_fh = new IO::File;
  $toc_fh->open(">$toc_fn")
	|| die("$0: file $toc_fn: $!\n");
  $toc_fh->print($_) for @$toc_aref;
  $toc_fh->close();

  my $restore_pipe = new IO::Pipe;
  my @restore_cmd = ('pg_restore', '-Fc', '-L', $toc_fn, $dump_fn);
  $restore_pipe->reader(@restore_cmd)
	|| die("$0: commmand @restore_cmd: $!\n");
  print($_) while <$restore_pipe>;
  $restore_pipe->close();
}




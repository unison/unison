#!/usr/bin/perl
#
# publicize -- remove proprietary info from a COPY-formatted
# psql dump.
#
# $Id: publicize,v 1.42 2006/06/26 18:05:08 rkh Exp $
# Reece Hart <rkh@gene.com>
#

# TODO:
# - filter entire schemas (e.g., sst)


use strict;
use warnings;
use Unison;
use Unison::pset;
use Storable;
use Data::Dumper;
use Getopt::Long qw(:config gnu_getopt);
use POSIX qw(strftime);

sub col_match($$@);
sub load_public_ids($);
sub log(@);

my $CVSId = '$Id: publicize,v 1.42 2006/06/26 18:05:08 rkh Exp $ ';

my %opts =
  (
   tick_minor => 100000,
   tick_major => 100000 * 50,
   pset => 'public'
  );

GetOptions(\%opts,
		   'tick_minor=i',
		   'tick_major=i',
		   'pset|S=s'
		  )
  || die("$0: bad usage. Even worse error message.\n");


select(STDERR); $|++;		# unbuffer stderr
select(STDOUT);

my $timestamp = timestamp();
print(STDERR "# $0\n",
      "# $CVSId\n",
      "# started at $timestamp\n");
print("-- $0\n",
      "-- $CVSId\n",
      "-- started at $timestamp\n");

# The following tables are included without any filtering
my @unfiltered_tables = qw(params pmhmm pmodel pmodel2go pmodelset
			   pmpssm pmregexp
			   pmsm pmsm_pmhmm pmsm_pmpssm
			   pmsm_pmregexp origin);

my $eodata_re = qr/^\\\./;
my $pseq_id_re = qr/^(pseq_id|[qt]_pseq_id|query|target)$/;
my $params_id_re = qr/^params_id$/;
my $origin_id_re = qr/^origin_id$/;
my $palias_id_re = qr/^palias_id$/;
my $truncate_tables_re = qr/p2gblat|pmprospect|paprospect|pmsm_pmprospect|pnote/;
my $unfiltered_tables_re = join('|',@unfiltered_tables);



my %public_ids = load_public_ids($opts{pset});

foreach my $id_class (sort keys %public_ids) {
  next unless ref $public_ids{$id_class};
  my $msg = sprintf("    %10d $id_class",
					scalar(grep {defined $_} @{$public_ids{$id_class}}));
  print('-- ', $msg, "\n");
  print(STDERR '# ', $msg, "\n");
}


if ( -t 0 ) {
  open(DUMP_IN, "pg_dump|")
	|| die("couldn't open pg_dump pipe\n");
  print(STDERR "# reading pgdump data from pg_dump pipe\n");
} else {
  open(DUMP_IN, "<&=STDIN");
  print(STDERR "# reading pgdump data from stdin\n");
}


my $table;								 # filtering COPY block if defined
my %id_cols;							   # hash of arrays; h by col name
my $printed = 0;
my %skipped;								# No. lines skipped
my %copied;								   # ... and copied, by table name

while ( my $line = <DUMP_IN> ) {
  # default is to print line as-is at end of loop; exceptions:
  # 1) skip to next line if row is proprietary
  # 2) modify text of current line (and then print it)

  my $tbl;
  my $cols;

  if (not defined $table) {	# == "if not filtering"
    # BEGIN extra-COPY parsing

    ########
    # Reject GRANT/REVOKE/CREATE SCHEMA/SSA
	# for any user other than PUBLIC or unison
	# not sure if this the right thing to do for some, e.g., pgtools schema
    if ( (   $line =~ m/^(?:GRANT|REVOKE).+(?:TO|FROM)\s+/ )
#		  or $line =~ m/^(?:CREATE SCHEMA.+|SET SESSION) AUTHORIZATION '/ )
		 and $' !~ m/PUBLIC|unison/
	   ) {
      print(STDERR "# skipped: $line");
      $line =~ s/^/-- /;	# comment it out
    }

    ########
    # Insert k/v pairs for publicization (ugh)
    elsif ( $line =~ m/^COPY meta/ ) {
      print(STDERR "# inserted meta k/v\n");
      $line .= <<EOT
publicized by	$CVSId
publicized at	$timestamp
EOT
	# $table not set, see above
    }

    ########
    # Some tables contain only proprietary data.  These would
    # be caught by the column-based rules below, but it's faster to
    # just fast forward across them.
    elsif ( $line =~ m/^COPY ($truncate_tables_re)/ ) {
	  my $tbl = $1;
      my $tlines = 0;
      print(STDERR "# table $tbl: truncating...");
      print $line;
      while ($line = <DUMP_IN>) {
		last if $line =~ $eodata_re;
		$tlines++;
      }
	  print $line;							# = eodata_re (\.)
      print(STDERR "done; $tlines lines truncated\n");
	  $skipped{$tbl} = $tlines;
	  $copied{$tbl} = 0;
	  next;
    }

    ########
    # Tables which shouldn't be filtered, even though
    # they might match column-based filtering below.
    elsif ( $line =~ m/^COPY ($unfiltered_tables_re)/ ) {
      print(STDERR "# table $1: unfiltered\n");
      # $table not set => no filtering
    }

    ########
    # Column-based filtering. Tables matching the following COPY regexp
    # are candidates for filtering based on the column names. 
    # WARNING: quoted column names (e.g., "start") aren't parsed
    # correctly, but this isn't currently a problem
    elsif ( ($tbl, $cols) = $line =~ m/^COPY (\S+) \(([^\)]+)\)/ ) {
      my @cols = split(/,\s*/,$cols);

	  # standard cols for all tables
      @{$id_cols{pseq}} 	= grep {$cols[$_]=~$pseq_id_re   } 0..$#cols;
      @{$id_cols{params}}	= grep {$cols[$_]=~$params_id_re } 0..$#cols;
      @{$id_cols{origin}}	= grep {$cols[$_]=~$origin_id_re} 0..$#cols;
      @{$id_cols{palias}}	= grep {$cols[$_]=~$palias_id_re } 0..$#cols;
      @{$id_cols{pmodel}}   = grep {$cols[$_]=~m/pmodel_id/} 0..$#cols;
	  @{$id_cols{pmap_aln}} = ();
	  @{$id_cols{pmap_hsp}} = ();
	  if ($tbl =~ m/^pmap/) {
		@{$id_cols{pmap_aln}} = grep {$cols[$_]=~m/aln_id/} 0..$#cols;
		@{$id_cols{pmap_hsp}} = grep {$cols[$_]=~m/hsp_id/} 0..$#cols;
	  }

      if (   @{$id_cols{pseq}}
	      or @{$id_cols{params}}
	      or @{$id_cols{origin}}
	      or @{$id_cols{palias}}
	      or @{$id_cols{pmodel}}
	      or @{$id_cols{pmap_aln}}
	      or @{$id_cols{pmap_hsp}}
		 ) {
		printf(STDERR "# table $tbl: filtering on o(%s), q(%s), a(%s), p(%s), m(%s), pmap(aln:%s,hsp:%s)\n",
			   join(',',@{$id_cols{origin}}),
			   join(',',@{$id_cols{pseq}}),
			   join(',',@{$id_cols{palias}}),
			   join(',',@{$id_cols{params}}),
			   join(',',@{$id_cols{pmodel}}),
			   join(',',@{$id_cols{pmap_aln}}),
			   join(',',@{$id_cols{pmap_hsp}}),
			  );
		$table = $tbl;
      } else {
		print(STDERR "# table $tbl: no filter cols\n");
		# table not set => no filtering
      }
    }

    ########
    # This is a sanity check. It shouldn't be hit.
    elsif ( $line =~ m/^COPY (\S+)/ ) {
      die("\n! fell through to COPY block for table $1\n# <$line");
    }

	if (defined $table) { 					# table must have just been set
	  $skipped{$table} = 0;
	  $copied{$table} = 0;
	}

    # END extra-COPY parsing


  } else {

    # BEGIN intra-COPY parsing

	# progress ticks:
	if ($. % $opts{tick_major} == 0) {
	  printf(STDERR " %12d\n",$.);
	} elsif ($. % $opts{tick_minor} == 0) {
	  print(STDERR '.');
	}

    ########
    if ( $line =~ $eodata_re ) {
      undef $table;
      undef %id_cols;
	  print(STDERR "done.\n");
    } else {
      my @F = split(/\t/, $line);
      chomp $F[$#F];
      # Note: if @{$id_cols{x}} is empty, we're not filtering on that column 
      # and col_match returns match
      if ( not (    col_match(\@{$public_ids{pseq}},    	\@F, @{$id_cols{pseq}}    )
				and col_match(\@{$public_ids{origin}}, 	\@F, @{$id_cols{origin}} )
				and col_match(\@{$public_ids{params}},  	\@F, @{$id_cols{params}}  )
				and col_match(\@{$public_ids{palias}}, 		\@F, @{$id_cols{palias}}  )
				and col_match(\@{$public_ids{pmodel}},		\@F, @{$id_cols{pmodel}}  )
				and col_match(\@{$public_ids{pmap_aln}},  	\@F, @{$id_cols{pmap_aln}}  )
				and col_match(\@{$public_ids{pmap_hsp}},  	\@F, @{$id_cols{pmap_hsp}}  )
			   ) ) {
		$skipped{$table}++;
		next;
      } else {
		$copied{$table}++;
	  }
    }
    # END intra-COPY parsing
  }

  # whether inside or outside of a COPY block
  print $line;
  $printed++;
}
print(STDERR "\n\n# done.\n");
my $nlines = $. + 1;
close(DUMP_IN);


print(STDERR "# table summary:\n");
print(       "-- table summary:\n");
foreach my $tbl (sort keys %skipped) {
  my $tot = $copied{$tbl}+$skipped{$tbl};
  my $line = sprintf("%20s: %12d total lines", $tbl, $tot);
  if ($tot > 0) {
	$line .= sprintf("; %12d (%6.2f%%) copied, %12d (%6.2f%%) skipped",
					 $copied{$tbl}, $copied{$tbl}/$tot*100,
					 $skipped{$tbl}, $skipped{$tbl}/$tot*100
					);
  }
  print(STDERR '# ',  $line, "\n");
  print(       '-- ', $line, "\n");
}

$timestamp = timestamp();
my $msg = sprintf("%12d printed / %12d lines total (%6.2f%%)",
				  $printed, $nlines, $printed/$nlines*100);
print(STDERR "# $msg\n# $0 finished at $timestamp\n");
print(       "-- $msg\n-- $0 finished at $timestamp\n");

exit(0);


########################################################################
########################################################################

sub timestamp () {
  strftime('%F %T %Z',localtime);
}

sub load_public_ids($) {
  # Generates and caches various ids to be made public, or reads them
  # from a cache.

  my $pset_name = shift;
  my $s_fn = "/tmp/$pset_name-public_ids.plst";

  if ( -f $s_fn ) {
    print(STDERR "# loading public ids from '$s_fn'...");
    (my $ref = retrieve($s_fn))
      || die("$0: retrieve failed on $s_fn\n");
    print(STDERR "done loading.\n",
	  "# public ids for set '$ref->{pset_name}' generated\n",
	  "#   on $ref->{timestamp}\n",
	  "#   by $ref->{CVSId}\n");
    if ($CVSId ne $ref->{CVSId}) {
      warn("!! ids were generated by a different version of $0\n");
    }
    return %$ref;
  }


  print(STDERR "# building public ids for set '$pset_name'. This takes ~15 minutes...\n");

  my $u = new Unison();

  my %ids;
  $ids{CVSId} = $CVSId;
  $ids{CVSRevision} = '$Revision: 1.42 $ ';
  $ids{pset_name} = $pset_name;
  $ids{timestamp} = $timestamp;


  my @public_pseq_ids = $u->pseq_ids_by_pset($pset_name);
  $ids{pseq}[$_]++ 			for @public_pseq_ids;
  printf(STDERR "%10d public_pseq_ids\n", $#public_pseq_ids+1);
  undef @public_pseq_ids;


  my @public_origin_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT)};
select origin_id from origin where is_public
EOT
  $ids{origin}[$_]++		for @public_origin_ids;
  printf(STDERR "%10d public_origin_ids\n", $#public_origin_ids+1);
  my $ppis = join(',',@public_origin_ids);
  undef @public_origin_ids;


  my @public_params_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT)};
select params_id from params where is_public
EOT
  $ids{params}[$_]++ 		for @public_params_ids;
  printf(STDERR "%10d public_params_ids\n", $#public_params_ids+1);
  undef @public_params_ids;


  my @public_palias_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT,undef,$pset_name)};
SELECT DISTINCT AO.palias_id
  FROM paliasorigin AO
  JOIN origin O on AO.origin_id=O.origin_id and O.is_public=TRUE
  JOIN pseqalias SA on AO.palias_id=SA.palias_id and SA.is_current=TRUE
  JOIN pseqset SS ON SA.pseq_id=SS.pseq_id and SS.pset_id=pset_id(?)
EOT
  $ids{palias}[$_]++ 		for @public_palias_ids;
  printf(STDERR "%10d public_palias_ids\n", $#public_palias_ids+1);
  undef @public_palias_ids;


  my @public_pmodel_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT,undef,$pset_name)};
SELECT DISTINCT pmodel_id
  FROM pmpseq M
  JOIN pseqset SS on M.pseq_id=SS.pseq_id
 WHERE SS.pset_id=pset_id(?)
EOT
  $ids{pmodel}[$_]++ 		for @public_pmodel_ids;
  printf(STDERR "%10d public_pmodel_ids\n", $#public_pmodel_ids+1);
  undef @public_pmodel_ids;


  my @public_pmap_hsp_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT,undef,$pset_name)};
SELECT DISTINCT hsp_id
  FROM pmap_hsp H
  JOIN pseqset SS on H.pseq_id=SS.pseq_id
  JOIN params P on H.params_id=P.params_id
 WHERE SS.pset_id=pset_id(?) and P.is_public;
EOT
  $ids{pmap_hsp}[$_]++		for @public_pmap_hsp_ids;
  printf(STDERR "%10d public_pmap_hsp_ids\n", $#public_pmap_hsp_ids+1);
  undef @public_pmap_hsp_ids;


  my @public_pmap_aln_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT,undef,$pset_name)};
SELECT DISTINCT aln_id
  FROM pmap_aln A
  JOIN pseqset SS on A.pseq_id=SS.pseq_id
  JOIN params P on A.params_id=P.params_id
 WHERE SS.pset_id=pset_id(?) and P.is_public;
EOT
  $ids{pmap_aln}[$_]++		for @public_pmap_aln_ids;
  printf(STDERR "%10d public_pmap_aln_ids\n", $#public_pmap_aln_ids+1);
  undef @public_pmap_aln_ids;


  if (not store(\%ids, $s_fn)) {
    warn("! store($s_fn) failed: $!\n");
  }
  print(STDERR "# stored public_ids in $s_fn\n");

  return %ids;
}


sub col_match($$@) {
  # given: ids, columns, col indices
  # returns: 0 if any column column referenced by indices is not "in" the ids array (vector)
  #		Otherwise, returns 1. Therefore, this fx returns 1 when given an empty index array
  my $pids = shift;
  my $colr = shift;
  while ( defined (my $i = shift) ) {
    return 0 if ($colr->[$i] ne '' and $colr->[$i] ne '\\N' and not $pids->[$colr->[$i]]);
  }
  return 1;
}

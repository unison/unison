#!/usr/bin/perl
#
# make-csb-public -- filter out proprietary data from a COPY-formatted
# psql dump
#
# $Id: make-csb-public,v 1.17 2005/07/14 00:54:06 rkh Exp $
# Reece Hart <rkh@gene.com>
#

# TODO:
# - rename
# - filter entire schemas (e.g., sst)


use strict;
use warnings;
use Unison;
use Unison::pset;
use Storable;
use Data::Dumper;

select(STDERR); $|++;						# unbuffer stderr
select(STDOUT);

my $pset_name = $ENV{PSET} || 'public';
my @public_porigins = qw(UniProt UniProt/TrEMBL PDB IPI RefSeq);
my @public_params_ids = qw(3 4 5 8 9 11 12 15 16 17 19 21 22);


my $eodata_re = qr/^\\\./;
my $pseq_id_re = qr/pseq_id|q_pseq_id|t_pseq_id|query|target/;
my $params_id_re = qr/params_id/;
my $porigin_id_re = qr/porigin_id/;
my $palias_id_re = qr/palias_id/;
my $filter_cols_re = qr/$pseq_id_re|$params_id_re|$porigin_id_re/;
my $CVSId = q$Id: make-csb-public,v 1.17 2005/07/14 00:54:06 rkh Exp $ ;

my $tick_minor = 500000;
my $tick_major = 20*$tick_minor;

sub col_match($$@);
sub load_public_ids($);


## it begins...

my %public_ids = load_public_ids($pset_name);
printf(STDERR "# %d pseq_ids, %d porigin_ids, %d params_ids, %d palias_ids will be public\n",
	   scalar(grep {defined $_} @{$public_ids{pseq}}),
	   scalar(grep {defined $_} @{$public_ids{porigin}}),
	   scalar(grep {defined $_} @{$public_ids{params}}),
	   scalar(grep {defined $_} @{$public_ids{palias}}),
	  );



my $table;									# filtering COPY block if defined
my @pseq_id_cols;
my @params_id_cols;
my @porigin_id_cols;
my @palias_id_cols;


while( my $line = <> ) {
  # default is to print this line at the end of the loop
  # exceptions are to: 1) skip to next line; 2) insert/append
  # text with current line.

  print(STDERR '.') if ($. % $tick_minor  == 0);
  printf(STDERR "%12d\n",$.) if ($. % $tick_major == 0);


  if ( $line =~ m/^COPY meta/ ) {
	my $TS = `/bin/date -u '+%Y-%m-%d %H:%M:%S'`; chomp $TS;
	$_ .= <<EOT
publicized by	$CVSId
publicized on	$TS
EOT


  } elsif ( my ($tbl, $cols) = $line =~ m/^COPY (\S+) \(([^\)]+)\)/ ) {
	my @cols = split(/,\s*/,$cols);
	@pseq_id_cols 	 = grep {$cols[$_]=~$pseq_id_re   } 0..$#cols;
	@params_id_cols	 = grep {$cols[$_]=~$params_id_re } 0..$#cols;
	@porigin_id_cols = grep {$cols[$_]=~$porigin_id_re} 0..$#cols;
	@palias_id_cols  = grep {$cols[$_]=~$palias_id_re } 0..$#cols;
	if (   @pseq_id_cols
		or @params_id_cols 
		or @porigin_id_cols
		or @palias_id_cols) {
	  printf(STDERR "\n# $tbl: o(%s), q(%s), a(%s), p(%s)\n",
			 join(',',@porigin_id_cols), join(',',@pseq_id_cols),
			 join(',',@palias_id_cols),	 join(',',@params_id_cols) );
	  $table = $tbl;
	}


  } elsif ( defined $table and $line =~ m/^\\\./ ) {
	undef $table;


  } elsif ( defined $table ) {
	my @F = split(/\t/, $line);
	chomp $F[$#F];
	next unless col_match(\@{$public_ids{pseq}},    \@F, @pseq_id_cols    );
	next unless col_match(\@{$public_ids{porigin}}, \@F, @porigin_id_cols );
	next unless col_match(\@{$public_ids{params}},  \@F, @params_id_cols  );
	next unless col_match(\@{$public_ids{palias}},  \@F, @palias_id_cols  );


  }	elsif ($line =~ m/^(?:GRANT|REVOKE).+(?!PUBLIC|unison|loader)/) {
	next;
  }

  print $line;
}




########################################################################
########################################################################

sub load_public_ids($) {
  my $pset_name = shift;
  my $s_fn = "/tmp/public_ids -- $pset_name.plst";
  my %ids;

  if ( -f $s_fn ) {
	print(STDERR "# loading public ids from '$s_fn'...");
	(my $ref = retrieve($s_fn))
	  || die("$0: retrieve failed on $s_fn\n");
	print(STDERR "done loading.\n",
		  "# public ids generated\n",
		  "  on $ref->{timestamp}\n",
		  "  by $ref->{CVSId}\n");
	if ($CVSId ne $ref->{CVSId}) {
	  warn("!! ids were generated by a different version of $0\n",
		   "!! This is $CVSId\n");
	}
	return %$ref;
  }

  print(STDERR "# building public_ids for set '$pset_name'. This takes 1-15 minutes...\n");
  my $u = new Unison(dbname=>'csb-dev');	# will be 'csb' when required sets are in production
  my @public_pseq_ids = $u->pseq_ids_by_pset($pset_name);
  my @public_porigin_ids = map {$u->porigin_porigin_id_by_origin($_)} @public_porigins;
  my $ppis = join(',',@public_porigin_ids);
  my @public_palias_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT,undef,$pset_name)};
SELECT DISTINCT A.palias_id
FROM v_current_annotations_unsorted A
JOIN pseqset S ON A.pseq_id=S.pseq_id
WHERE S.pset_id=pset_id(?) AND A.porigin_id IN ($ppis)
EOT

  $ids{pseq}[$_]++ for @public_pseq_ids;
  $ids{porigin}[$_]++ for @public_porigin_ids;
  $ids{params}[$_]++ for @public_params_ids;
  $ids{palias}[$_]++ for @public_palias_ids;
  $ids{CVSId} = $CVSId;
  $ids{CVSRevision} = q$Revision: 1.17 $ ;
  $ids{pset_name} = $pset_name;
  $ids{timestamp} = `/bin/date -u '+%Y-%m-%d %H:%M:%S'`; chomp($ids{timestamp});

  if (not store(\%ids, $s_fn)) {
	warn("! store($s_fn) failed: $!\n");
  }
  print(STDERR "# stored public_ids in $s_fn\n");

  return %ids;
}


sub col_match($$@) {
  # given: ids, columns, col indices
  # returns: 0 if any column column referenced by indices is not "in" the ids array (vector)
  #		Otherwise, returns 1. Therefore, this fx returns 1 when given an empty index array
  my $pids = shift;
  my $colr = shift;
  while( defined (my $i = shift) ) {
	return 0 if ($colr->[$i] ne '\\N' and not $pids->[$colr->[$i]]);
  }
  return 1;
}

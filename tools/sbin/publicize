#!/usr/bin/perl
#
# publicize -- remove proprietary info from a COPY-formatted
# psql dump.
#
# $Id: publicize,v 1.22 2005/07/17 21:21:38 rkh Exp $
# Reece Hart <rkh@gene.com>
#

# TODO:
# - filter entire schemas (e.g., sst)


use strict;
use warnings;
use Unison;
use Unison::pset;
use Storable;
use Data::Dumper;

select(STDERR); $|++;						# unbuffer stderr
select(STDOUT);

my $pset_name = $ENV{PSET} || 'public';
my @public_porigins = qw(UniProt UniProt/TrEMBL PDB IPI RefSeq);
my @public_params_ids = qw(3 4 5 8 9 11 12 15 16 17 19 21 22);
my @unfiltered_tables = qw(pmhmm pmodel pmodel2go pmodelset pmprospect2
						   pmprospect2_scop pmpssm pmregexp pmsm
						   pmsm_pmhmm pmsm_pmpssm pmsm_prospect2
						   pmsm_regexp);

my $tick_minor = 100000;
my $tick_major = 50*$tick_minor;

my $eodata_re = qr/^\\\./;
my $pseq_id_re = qr/pseq_id|q_pseq_id|t_pseq_id|query|target/;
my $params_id_re = qr/params_id/;
my $porigin_id_re = qr/porigin_id/;
my $palias_id_re = qr/palias_id/;
my $truncate_tables_re = qr/paprospect2|pnote/;
my $unfiltered_tables_re = join('|',@unfiltered_tables);

my $CVSId = q$Id: publicize,v 1.22 2005/07/17 21:21:38 rkh Exp $ ;
my $timestamp = `/bin/date '+%Y-%m-%d %H:%M:%S %Z'`; chomp $timestamp;

my %conn_info = (dbname=>'csb-dev',			# evenutally, csb
				 username=>'PUBLIC');

sub col_match($$@);
sub load_public_ids($);
sub log(@);



## it begins...

print(STDERR "# $0\n",
	  "# $CVSId\n",
	  "# started at $timestamp\n");
print("-- $0\n",
	  "-- $CVSId\n",
	  "-- started at $timestamp\n");

my %public_ids = load_public_ids($pset_name);

printf(STDERR "# %d pseq_ids, %d porigin_ids, %d params_ids, %d palias_ids will be public\n",
	   scalar(grep {defined $_} @{$public_ids{pseq}}),
	   scalar(grep {defined $_} @{$public_ids{porigin}}),
	   scalar(grep {defined $_} @{$public_ids{params}}),
	   scalar(grep {defined $_} @{$public_ids{palias}}),
	  );
printf("-- %d pseq_ids, %d porigin_ids, %d params_ids, %d palias_ids will be public\n",
	   scalar(grep {defined $_} @{$public_ids{pseq}}),
	   scalar(grep {defined $_} @{$public_ids{porigin}}),
	   scalar(grep {defined $_} @{$public_ids{params}}),
	   scalar(grep {defined $_} @{$public_ids{palias}}),
	  );


my $table;									# filtering COPY block if defined
my $printed = 0;
my %skipped;
my @pseq_id_cols;
my @params_id_cols;
my @porigin_id_cols;
my @palias_id_cols;


while( my $line = <> ) {
  # default is to print line as-is at end of loop; exceptions:
  # 1) skip to next line if row is proprietary
  # 2) modify text of current line (and then print it)

  if 	($. % $tick_major == 0) { printf(STDERR "%12d\n",$.) }
  elsif ($. % $tick_minor == 0) { print(STDERR '.')			 }; 


  if (not defined $table) {					# == "if not filtering"
	# BEGIN extra-COPY parsing

	########
	# Reject GRANT/REVOKE for any user other than PUBLIC or unison
	# Those users must exist.
	# WARNING: the following is broken
	# '0 and ' is intentionally disabling it
	if (0 and $line =~ m/^(?:GRANT|REVOKE).+(?!PUBLIC|unison)/) {
	  print(STDERR "# skipped: $line");
	  $line =~ s/^/-- /;					# comment it out 
	}

	########
	# Insert k/v pairs for publicization (ugh)
	elsif ( $line =~ m/^COPY meta/ ) {
	  print(STDERR "# inserted meta k/v\n");
	  $line .= <<EOT
publicized by	$CVSId
publicized at	$timestamp
EOT
	  # $table not set, see above
    }

	########
	# Some tables contain only proprietary data.  These would
	# be caught by the column-based rules below, but it's faster to
	# just fast forward across them.
	elsif ( $line =~ m/^COPY ($truncate_tables_re)/ ) {
	  my $tlines = 0;
	  my $start = $.;
	  print(STDERR "# truncating: table $1...");
	  print $line;
	  while($line = <>) {
		last if $line =~ $eodata_re; 
		$tlines++;
	  }
	  printf(STDERR "$tlines/%d lines truncated\n", $.-$start-1);
	}

	########
	# Tables which shouldn't be filtered, even though
	# they might match column-based filtering below.
	elsif ( $line =~ m/^COPY ($unfiltered_tables_re)/ ) {
	  print(STDERR "# not filtering: table $1\n");
	  # $table not set => won't enter filtering loop and all
	  # lines will be included as-is
	}

	########
	# Column-based filtering. Tables matching the following COPY regexp
	# are candidates for filtering based on the column names. 
    # WARNING: quoted column names (e.g., "start") aren't parsed
	# correctly, but this isn't currently a problem
	elsif ( my ($tbl, $cols) = $line =~ m/^COPY (\S+) \(([^\)]+)\)/ ) {
	  my @cols = split(/,\s*/,$cols);
	  @pseq_id_cols 	 = grep {$cols[$_]=~$pseq_id_re   } 0..$#cols;
	  @params_id_cols	 = grep {$cols[$_]=~$params_id_re } 0..$#cols;
	  @porigin_id_cols = grep {$cols[$_]=~$porigin_id_re} 0..$#cols;
	  @palias_id_cols  = grep {$cols[$_]=~$palias_id_re } 0..$#cols;
	  if (   @pseq_id_cols
			 or @params_id_cols 
			 or @porigin_id_cols
			 or @palias_id_cols) {
		printf(STDERR "\n# $tbl: o(%s), q(%s), a(%s), p(%s)\n",
			   join(',',@porigin_id_cols), join(',',@pseq_id_cols),
			   join(',',@palias_id_cols),	 join(',',@params_id_cols) );
		$table = $tbl;
	  } else {
		print(STDERR "# COPY wo/filter cols: $line");
	  }
	}

	########
	# This is a sanity check. It shouldn't be hit.
	elsif ( $line =~ m/^COPY (\S+)/ ) {
	  die("# fell through to COPY block for table $1\n# <$line");
	}

	# END extra-COPY parsing

  } else {

	# BEGIN intra-COPY parsing

	########
	if ( $line =~ $eodata_re ) {
	  undef $table;
	} else {
	  my @F = split(/\t/, $line);
	  chomp $F[$#F];
	  # Note: if @x_id_cols is empty, we're not filtering on that column 
	  # and col_match returns match
	  if ( not (    col_match(\@{$public_ids{pseq}},    \@F, @pseq_id_cols    )
			    and col_match(\@{$public_ids{porigin}}, \@F, @porigin_id_cols )
			    and col_match(\@{$public_ids{params}},  \@F, @params_id_cols  )
			    and col_match(\@{$public_ids{palias}},  \@F, @palias_id_cols  ) ) ) {
		$skipped{$table}++;
		next;
	  }
	}
	# END intra-COPY parsing
  }
  
  # whether inside or outside of a COPY block
  print $line;
  $printed++;
}
print(STDERR "done.\n");


$timestamp = `/bin/date '+%Y-%m-%d %H:%M:%S %Z'`; chomp $timestamp;
printf(STDERR "# $0 finished at %s\n# %12d printed / %12d lines total (%5.1f%%)\n",
	   $timestamp,$printed,$.,$printed/$.*100);
printf("-- $0 finished at %s\n-- %12d printed / %12d lines total (%5.1f%%)\n",
	   $timestamp,$printed,$.,$printed/$.*100);

foreach my $tbl (sort keys %skipped) {
  printf("$tbl: %10d lines skipped\n", $skipped{$tbl})
}

exit(0);


########################################################################
########################################################################

sub load_public_ids($) {
  my $pset_name = shift;
  my $s_fn = "/tmp/public_ids -- $pset_name.plst";
  my %ids;

  if ( -f $s_fn ) {
	print(STDERR "# loading public ids from '$s_fn'...");
	(my $ref = retrieve($s_fn))
	  || die("$0: retrieve failed on $s_fn\n");
	print(STDERR "done loading.\n",
		  "# public ids generated\n",
		  "#   on $ref->{timestamp}\n",
		  "#   by $ref->{CVSId}\n",
		  "#   for set '$ref->{pset_name}'\n");
	if ($CVSId ne $ref->{CVSId}) {
	  warn("!! ids were generated by a different version of $0\n",
		   "!! This is $CVSId\n");
	}
	return %$ref;
  }

  print(STDERR "# building public_ids for set '$pset_name'. This takes 1-15 minutes...\n");
  my $u = new Unison(%conn_info);
  my @public_pseq_ids = $u->pseq_ids_by_pset($pset_name);
  my @public_porigin_ids = map {$u->porigin_porigin_id_by_origin($_)} @public_porigins;
  my $ppis = join(',',@public_porigin_ids);
  my @public_palias_ids = map {$_->[0]} @{$u->selectall_arrayref(<<EOT,undef,$pset_name)};
SELECT DISTINCT A.palias_id
FROM v_current_annotations_unsorted A
JOIN pseqset S ON A.pseq_id=S.pseq_id
WHERE S.pset_id=pset_id(?) AND A.porigin_id IN ($ppis)
EOT

  $ids{pseq}[$_]++ for @public_pseq_ids;
  $ids{porigin}[$_]++ for @public_porigin_ids;
  $ids{params}[$_]++ for @public_params_ids;
  $ids{palias}[$_]++ for @public_palias_ids;
  $ids{CVSId} = $CVSId;
  $ids{CVSRevision} = q$Revision: 1.22 $ ;
  $ids{pset_name} = $pset_name;
  $ids{timestamp} = $timestamp;

  if (not store(\%ids, $s_fn)) {
	warn("! store($s_fn) failed: $!\n");
  }
  print(STDERR "# stored public_ids in $s_fn\n");

  return %ids;
}


sub col_match($$@) {
  # given: ids, columns, col indices
  # returns: 0 if any column column referenced by indices is not "in" the ids array (vector)
  #		Otherwise, returns 1. Therefore, this fx returns 1 when given an empty index array
  my $pids = shift;
  my $colr = shift;
  while( defined (my $i = shift) ) {
	return 0 if ($colr->[$i] ne '' and $colr->[$i] ne '\\N' and not $pids->[$colr->[$i]]);
  }
  return 1;
}

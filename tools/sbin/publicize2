#!/usr/bin/perl

use strict;
use warnings;

use File::Temp qw(tempdir);
use IO::File;
use IO::Pipe;
use Getopt::Long qw(:config gnu_compat);
use IPC::Open2;
use Time::HiRes qw(gettimeofday tv_interval);
use POSIX qw(strftime);
use DBI;



select(STDERR); $|++;
select(STDOUT); $|++;

sub get_table_info($);
sub get_schema_dump($$);
sub get_dump_toc($);
sub restore_subset($$);
sub origin_join($);
sub params_join($);
sub typical_join($$$$);


my $CVSId = q$Id: publicize2,v 1.2 2007/04/16 03:05:01 rkh Exp $; 
my @PHASE1_KW = qw(AGGREGATE FUNCTION PROCEDURAL SCHEMA SEQUENCE TABLE TYPE VIEW);
my $TERM_STRING = '__END_OF_COPY__';
my $VERBOSE_FREQ = 25000;
my %IGNORE_SCHEMAS = map {$_=>1} qw( mukhyala rkh matthejb twu cavs );
my %IGNORE_TABLES = map {$_=>1} qw( unison.p2gblataln unison.p2gblatalnhsp unison.p2gblathsp
		unison.paprospect );

our $PUBLIC_PARAMS_IDS = 'SELECT params_id FROM params WHERE is_public=TRUE';
our $PUBLIC_ORIGIN_IDS = 'SELECT origin_id FROM origin WHERE is_public=TRUE';
our $PUBLIC_PSEQ_IDS = qq(
						SELECT pseq_id FROM pseqset where pset_id=pset_id('public')
						AND SA.pseq_id < 1000
						);


my %copy_command =
  (
   # 0' dependencies
   'unison.origin'			=> 'SELECT O.* FROM ONLY origin O WHERE O.is_public=TRUE',
   'unison.params'			=> qq(
								 SELECT T.*
								 FROM ONLY params T
								 LEFT JOIN porigin O ON (T.model_origin_id=O.origin_id 
														 AND O.is_public=TRUE)
								 WHERE T.is_public=TRUE
								),

   # 1' dependencies
   'unison.paliasorigin'	=> \&origin_join,
   'unison.pmhmm'			=> \&origin_join,
   'unison.pmprospect'		=> \&origin_join,
   'unison.pmpssm'			=> \&origin_join,
   'unison.pmregexp'		=> \&origin_join,
   'unison.pseq2go'			=> \&origin_join,

   'unison.paprospect'		=> \&params_join,
   'unison.pfantigenic'		=> \&params_join,
   'unison.pfbigpi'			=> \&params_join,
   'unison.pfpepcoil'		=> \&params_join,
   'unison.pfpsipred'		=> \&params_join,
   'unison.pfregexp'		=> \&params_join,
   'unison.pfseg'			=> \&params_join,
   'unison.pfsignalphmm'	=> \&params_join,
   'unison.pfsignalpnn'		=> \&params_join,
   'unison.pftmdetect'		=> \&params_join,
   'unison.pftmhmm'			=> \&params_join,
   'unison.pmap_aln'		=> \&params_join,
   'unison.pmap_hsp'		=> \&params_join,
   'unison.psdisorder'		=> \&params_join,
   'unison.psipred'			=> \&params_join,
   'unison.psprotcomp'		=> \&params_join,

   # 1' joins where join columns are not same-named
   # ASSUMPTION: if there are multiple params_ids for a given pftype, the
   # preferred_params_id is public; if not true, we'll toss the pftype even though there
   # are other appropriate *public* params_ids.
   'unison.pftype'			=> qq(
								SELECT T.*
								FROM ONLY unison.pftype T
								JOIN params P on T.preferred_params_id=P.params_id
								WHERE P.is_public = TRUE
							   ),

   # 2' and 2-way dependencies
   # Several of the following SQL queries select public sequnces using
   # pseqalias~paliasorigin~origin.  I should consider putting this in a
   # subquery or the PUBLIC pseqset.
   'unison.pseq'			=> qq(
								SELECT T.*
								FROM ONLY pseq T
							    JOIN ($PUBLIC_PSEQ_IDS) PQ on T.pseq_id=PQ.pseq_id
							   ),

   'unison.pahmm'			=> qq(
								SELECT A.*
								FROM ONLY pahmm A
								JOIN pmhmm M ON A.pmodel_id=M.pmodel_id
								JOIN unison.origin O ON M.origin_id=O.origin_id AND O.is_public=TRUE
								JOIN params P ON A.params_id=P.params_id AND P.is_public=TRUE
							   ),

   'unison.pmpseq'			=> qq(
								SELECT DISTINCT M.*
								FROM ONLY pmpseq M
							    JOIN ($PUBLIC_PSEQ_IDS) PQ on M.pseq_id=PQ.pseq_id
							   ),

   'unison.papseq'			=> qq(
								SELECT DISTINCT A.*
								FROM ONLY papseq A
								JOIN pmpseq M ON A.pmodel_id=M.pmodel_id
							    JOIN ($PUBLIC_PSEQ_IDS) PQ on M.pseq_id=PQ.pseq_id
								JOIN unison.params P ON A.params_id=P.params_id AND P.is_public=TRUE
							   ),

   'unison.run_history'		=> qq(
								SELECT RH.*
								FROM ONLY run_history RH
								JOIN unison.origin O ON RH.origin_id=O.origin_id 	AND O.is_public=TRUE
								JOIN params P ON RH.params_id=P.params_id 			AND P.is_public=TRUE
							    JOIN ($PUBLIC_PSEQ_IDS) PQ on RH.pseq_id=PQ.pseq_id
							   ),

   'unison.pseqset'			=> qq(
								SELECT SS.*
								FROM ONLY pseqset SS
							    JOIN ($PUBLIC_PSEQ_IDS) PQ on SS.pseq_id=PQ.pseq_id
							   ),

   'unison.pmsm_pmhmm'		=> qq(
								SELECT MS.*
								FROM ONLY unison.pmsm_pmhmm MS
								JOIN unison.pmhmm M on MS.pmodel_id=M.pmodel_id
								JOIN unison.origin O on M.origin_id=O.origin_id
								WHERE O.is_public = TRUE
							   ),

   'unison.pmsm_pmpsssm'		=> qq(
								SELECT MS.*
								FROM ONLY unison.pmsm_pmpssm MS
								JOIN unison.pmpssm M on MS.pmodel_id=M.pmodel_id
							    JOIN unison.origin O on M.origin_id=O.origin_id
								WHERE O.is_public = TRUE
							   ),


  );


our $phase1_re = join('|',@PHASE1_KW);
our $tmp_dir = '/tmp/'; #tempdir( CLEANUP => 1 );
our $dump_fn = "$tmp_dir/pgdump";


my $all_start = [gettimeofday];
print(STDERR 
	  "# $0\n",
	  "# $CVSId\n",
	  "# started: ", strftime("%F %T %Z",localtime()), "\n"
	 );

my $src_db;
defined ($src_db = shift)
  || die("$0: missing source database name\n");

get_table_info($src_db);

get_schema_dump($src_db,$dump_fn);			# dies on error

my @toc = get_dump_toc($dump_fn);			# dies on error
printf(STDERR "%d TOC entries\n", $#toc+1);

restore_subset( $dump_fn, [grep { m/\s(?:$phase1_re)\s/ } @toc] );

my ($src_psql_w,$src_psql_r);
my $src_psql_pid = open2($src_psql_r,$src_psql_w,'psql', '-d', $src_db);
my @table_tocs = grep { m/^\d+; \d+ \d+ TABLE / } @toc;
for(my $i=0; $i<=$#table_tocs; $i++) {
  my $table_start = [gettimeofday];

  my ($schema,$table) = $table_tocs[$i] =~ m/^\d+; \d+ \d+ TABLE (\S+) (\S+)/;
  die("$0: table is undefined!") unless defined $table;

  my $st = "$schema.$table";
  my $pfx = sprintf("* %3d/%3d %-30s", $i+1, $#table_tocs+1, "$st: ");
  if (exists $IGNORE_SCHEMAS{$schema}) {
	printf(STDERR "$pfx   %15s\n", 'schema skipped');
	next;
  }
  if (exists $IGNORE_TABLES{$st}) {
	printf(STDERR "$pfx   %15s\n", 'table skipped');
	next;
  }

  my $src_copy;
  if (not exists $copy_command{$st}) {
	$src_copy = "SELECT * FROM $st";
	$pfx .= ' =';
  } elsif (ref $copy_command{$st} eq 'CODE') {
	$src_copy = $copy_command{$st}($st);
	$pfx .= ' *';
  } else {
	$src_copy = $copy_command{$st};
	$pfx .= ' *';
  }
  #$src_copy = "$src_copy LIMIT 10";
  $src_copy = "($src_copy)";

  print(STDERR "$pfx  (querying)\r") if (-t 1);
  print("COPY $st FROM STDIN;\n");
  $src_psql_w->print("COPY $src_copy TO STDOUT;\n");
  $src_psql_w->print("\\echo $TERM_STRING\n");
  my $nrows = 0;
  while (my $line = <$src_psql_r>) {
	if ($line =~ m/^ERROR:/) {
	  die("Oh, man, are you in trouble.\n$line\n");
	}
	if ($line =~ m/^$TERM_STRING/) {
	  print("\\.\n");
	  last;
	}
	print($line);
	$nrows++;
	printf("$pfx %15s\r","$nrows rows") if (-t 1 and $nrows % $VERBOSE_FREQ == 0);
  }
  printf("$pfx %15s (%d s)\n",
		 "$nrows rows",tv_interval($table_start));
}
$src_psql_w->print("\\q\n");
print(STDERR "waiting for src psql pipe process to die [pid=$src_psql_pid]\n");
waitpid($src_psql_pid,0);
print(STDERR "# src psql process finished\n");

restore_subset( $dump_fn, [grep { not m/\s(?:$phase1_re)\s/ } @toc] );

# !! comment, search_path, analyze

print(STDERR "# $0\n",
	  '# ended: ', strftime("%F %T %Z",localtime()),
	  ' (', sprintf("%.1f",tv_interval($all_start)/60/60), " h elapsed)\n");

exit(0);



## ######################################################################
## INTERNALS

sub get_table_info($) {
  my ($db) = @_;
  my %table_info;
  my $dbi = DBI->connect("dbi:Pg:dbname=$db", undef, undef,
						 { RaiseError => 1, AutoCommit => 0 })
	|| die $DBI::errstr;
  my $sth = $dbi->prepare( q(
				  			SELECT fk_namespace,fk_relation,fk_column,
								   pk_namespace,pk_relation,pk_column,ud
							FROM pgutils.foreign_keys
				            ) );
  $sth->execute();
  my $nfks;
  while( my $row = $sth->fetchrow_hashref() ) {
	$nfks++;
	my $st = "$row->{fk_namespace}.$row->{fk_relation}";
	$table_info{$st}{$row->{fk_column}} = \@{$row->{qw(pk_namespace pk_relation pk_column ud)}};
  }
  $sth->finish();
  $dbi->disconnect();
  printf(STDERR "# %d FKs in %d tables\n", $nfks, scalar keys %table_info);
  return %table_info;
}

sub get_schema_dump($$) {
  my ($db,$fn) = @_;
  my @cmd = ('pg_dump', '-Fc', '-s', '-f', $fn, $db);
  system(@cmd)
	&& die("@cmd: $!\n");
}

sub get_dump_toc($) {
  my $fn = shift;
  my $io = new IO::Pipe;
  my @cmd = ('pg_restore', '-l', $fn);
  $io->reader(@cmd)
	|| die("@cmd: $!\n");
  return grep { not /^;/ } <$io>;
}

sub restore_subset($$) {
  my ($dump_fn,$toc_aref) = @_;
  my $toc_fn = "$tmp_dir/toc";

  my $toc_fh = new IO::File;
  $toc_fh->open(">$toc_fn")
	|| die("$0: file $toc_fn: $!\n");
  $toc_fh->print($_) for @$toc_aref;
  $toc_fh->close();

  my $restore_pipe = new IO::Pipe;
  my @restore_cmd = ('pg_restore', '-Fc', '-L', $toc_fn, $dump_fn);
  $restore_pipe->reader(@restore_cmd)
	|| die("$0: commmand @restore_cmd: $!\n");
  print($_) while <$restore_pipe>;
  $restore_pipe->close();
}



sub origin_join($) { return typical_join(@_,undef,undef,1); }
sub params_join($) { return typical_join(@_,undef,1,undef); }
sub typical_join($$$$) {
  my ($st,$q,$o,$p) = shift;
  $q = 'pseq_id'	if defined $q and $q eq '1';
  $o = 'params_id'	if defined $o and $o eq '1';
  $p = 'origin_id'	if defined $p and $p eq '1';
  return
	(
	 "SELECT T.* FROM ONLY $st T\n"
	 . (defined $q ? "  JOIN ($PUBLIC_PSEQ_IDS)   PQ on T.$q=PQ.pseq_id\n" : '')
	 . (defined $p ? "  JOIN ($PUBLIC_PARAMS_IDS) PP on T.$p=PP.pseq_id\n" : '')
	 . (defined $o ? "  JOIN ($PUBLIC_ORIGIN_IDS) PO on T.$o=PO.pseq_id\n" : '')
	);
}


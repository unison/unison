#!/usr/bin/perl

use strict;
use warnings;

use File::Temp qw(tempdir);
use IO::File;
use IO::Pipe;
use Getopt::Long qw(:config gnu_compat);
use IPC::Open2;
use Time::HiRes qw(gettimeofday tv_interval);
use POSIX qw(strftime);


select(STDERR); $|++;
select(STDOUT); $|++;

sub get_schema_dump($$);
sub get_dump_toc($);
sub restore_subset($$$);
sub trivial_origin_join($);
sub trivial_params_join($);


my @PHASE1_KW = qw(AGGREGATE FUNCTION PROCEDURAL SCHEMA SEQUENCE TABLE TYPE VIEW);
my $TERM_STRING = '__END_OF_COPY__';
my $VERBOSE_FREQ = 25000;
my %IGNORE_SCHEMAS = map {$_=>1} qw( mukhyala rkh matthejb twu );
my %IGNORE_TABLES = map {$_=>1} qw( unison.p2gblataln unison.p2gblatalnhsp unison.p2gblathsp );

my $PUBLIC_SEQUENCES = qq(
						SELECT DISTINCT SA.pseq_id
						FROM ONLY pseqalias SA
						JOIN paliasorigin AO on SA.palias_id=AO.palias_id
						JOIN origin O on AO.origin_id=O.origin_id
						WHERE O.is_public = TRUE
						);


my %COPY_COMMAND =
  (
   # 0' dependencies
   'unison.origin'			=> 'SELECT T.* FROM ONLY origin WHERE is_public=TRUE',
   'unison.params'			=> qq(
								 SELECT T.*
								 FROM ONLY params T
								 JOIN porigin O ON T.pmodel_origin_id=O.origin_id
								 WHERE T.is_public=TRUE AND O.is_public=TRUE
								),

   # 1' dependencies
   'unison.paliasorigin'	=> \&trivial_origin_join,
   'unison.pmhmm'			=> \&trivial_origin_join,
   'unison.pmprospect'		=> \&trivial_origin_join,
   'unison.pmpssm'			=> \&trivial_origin_join,
   'unison.pmregexp'		=> \&trivial_origin_join,
   'unison.pseq2go'			=> \&trivial_origin_join,

   'unison.paprospect'		=> \&trivial_params_join,
   'unison.pfantigenic'		=> \&trivial_params_join,
   'unison.pfbigpi'			=> \&trivial_params_join,
   'unison.pfpepcoil'		=> \&trivial_params_join,
   'unison.pfpsipred'		=> \&trivial_params_join,
   'unison.pfregexp'		=> \&trivial_params_join,
   'unison.pfseg'			=> \&trivial_params_join,
   'unison.pfsignalphmm'	=> \&trivial_params_join,
   'unison.pfsignalpnn'		=> \&trivial_params_join,
   'unison.pftmdetect'		=> \&trivial_params_join,
   'unison.pftmhmm'			=> \&trivial_params_join,
   'unison.pmap_aln'		=> \&trivial_params_join,
   'unison.pmap_hsp'		=> \&trivial_params_join,
   'unison.psdisorder'		=> \&trivial_params_join,
   'unison.psipred'			=> \&trivial_params_join,
   'unison.psprotcomp'		=> \&trivial_params_join,

   # 1' joins where join columns are not same-named
   # ASSUMPTION: if there are multiple params_ids for a given pftype, the
   # preferred_params_id is public; if not true, we'll toss the pftype even though there
   # are other appropriate *public* params_ids.
   'unison.pftype'			=> qq(
								SELECT T.*
								FROM ONLY unison.pftype T
								JOIN params_id P on T.preferred_params_id=P.params_id
								WHERE P.is_public = TRUE
							   ),

   # 2' and 2-way dependencies
   # Several of the following SQL queries select public sequnces using
   # pseqalias~paliasorigin~origin.  I should consider putting this in a
   # subquery or the PUBLIC pseqset.
   'unison.pseq'			=> qq(
								SELECT T.*
								FROM ONLY pseq T
							    JOIN ($PUBLIC_SEQUENCES) PQ on T.pseq_id=PQ.pseq_id
							   ),

   'unison.pahmm'			=> qq(
								SELECT A.*
								FROM ONLY pahmm A
								JOIN pmhmm M ON A.pmodel_id=M.pmodel_id
								JOIN unison.origin O ON M.origin_id=O.origin_id AND O.is_public=TRUE
								JOIN params P ON A.params_id=P.params_id AND P.is_public=TRUE
							   ),

   'unison.pmpseq'			=> qq(
								SELECT DISTINCT M.*
								FROM ONLY pmpseq M
							    JOIN ($PUBLIC_SEQUENCES) PQ on M.pseq_id=PQ.pseq_id
							   ),

   'unison.papseq'			=> qq(
								SELECT DISTINCT A.*
								FROM ONLY papseq A
								JOIN pmpseq M ON A.pmodel_id=M.pmodel_id
							    JOIN ($PUBLIC_SEQUENCES) PQ on M.pseq_id=PQ.pseq_id
								JOIN unison.params P ON A.params_id=P.params_id AND P.is_public=TRUE
							   ),

   'unison.run_history'		=> qq(
								SELECT RH.*
								FROM ONLY run_history RH
								JOIN unison.origin O ON RH.origin_id=O.origin_id 	AND O.is_public=TRUE
								JOIN params P ON RH.params_id=P.params_id 			AND P.is_public=TRUE
							    JOIN ($PUBLIC_SEQUENCES) PQ on RH.pseq_id=PQ.pseq_id
							   ),

   'unison.pseqset'			=> qq(
								SELECT SS.*
								FROM ONLY pseqset SS
							    JOIN ($PUBLIC_SEQUENCES) PQ on SS.pseq_id=PQ.pseq_id
							   ),

   'unison.pmsm_pmhmm'		=> qq(
								SELECT MS.*
								FROM ONLY unison.pmsm_pmhmm
								JOIN unison.pmhmm M on MS.pmodel_id=M.pmodel_id
								JOIN unison.origin O on M.origin_id=O.origin_id
								WHERE O.is_public = TRUE;
							   ),

   'unison.pmsm_pmpseq'		=> qq(
								SELECT MS.*
								FROM ONLY unison.pmsm_pmhmm MS
								JOIN unison.pmpseq M on MS.pmodel_id=M.pmodel_id
							    JOIN ($PUBLIC_SEQUENCES) PQ on M.pseq_id=PQ.pseq_id
							   ),


  );


my $phase1_re = join('|',@PHASE1_KW);
my $tmp_dir = '/tmp/'; #tempdir( CLEANUP => 1 );
my $dump_fn = "$tmp_dir/pgdump";


my $all_start = [gettimeofday];
print(STDERR "# $0\n",
	  "# started: ", strftime("%F %T %Z",localtime()), "\n");

my $src_db;
defined ($src_db = shift)
  || die("$0: missing source database name\n");

my $dst_db = "pub_$src_db";

system( qw(dropdb), $dst_db );
system( qw(createdb -O unison), $dst_db )
  && die("$0: command createdb: $!\n");


#get_schema_dump($src_db,$dump_fn);			# dies on error
my @toc = get_dump_toc($dump_fn);			# dies on error
printf(STDERR "%d TOC entries\n", $#toc+1);

# dst_psql_pipe
# this is a single pipe for all restoration phases
# It may be worth considering 3 separate reconnections for the rebuild, ie
# pg_restore -l phase1 | psql
# script | psql -d src | psql -d dest
# pg_restore -l phase2 | psql
my $dst_psql_pipe = new IO::Pipe;
my @dst_psql_cmd = ('psql', '-q', '-d', $dst_db, '-f-');
#my @dst_psql_cmd = ('/bin/sh', '-c', "psql -q -d $dst_db 2>&1");
$dst_psql_pipe->writer( @dst_psql_cmd )
  || die("$0: @dst_psql_cmd: $!\n");


restore_subset( $dst_psql_pipe, $dump_fn, [grep { m/\s(?:$phase1_re)\s/ } @toc] );


my ($src_psql_w,$src_psql_r);
my $src_psql_pid = open2($src_psql_r,$src_psql_w,'psql', '-d', $src_db);
my @table_tocs = grep { m/^\d+; \d+ \d+ TABLE / } @toc;
for(my $i=0; $i<=$#table_tocs; $i++) {
  my $table_start = [gettimeofday];

  my ($schema,$table) = $table_tocs[$i] =~ m/^\d+; \d+ \d+ TABLE (\S+) (\S+)/;
  die("$0: table is undefined!") unless defined $table;

  my $st = "$schema.$table";
  my $pfx = sprintf("* %3d/%3d %-30s", $i+1, $#table_tocs+1, "$st: ");
  if (exists $IGNORE_SCHEMAS{$schema}) {
	printf(STDERR "$pfx   %15s\n", 'schema skipped');
	next;
  }
  if (exists $IGNORE_TABLES{$st}) {
	printf(STDERR "$pfx   %15s\n", 'table skipped');
	next;
  }

  my $src_copy;
  if (not exists $COPY_COMMAND{$st}) {
	$src_copy = "(SELECT * FROM $src_copy LIMIT 10)";
	$pfx .= ' =';
  } elsif (ref $COPY_COMMAND{$st} eq 'CODE') {
	$src_copy = $COPY_COMMAND{$st}($st);
	$src_copy = "($src_copy LIMIT 10)";
	$pfx .= ' *';
  } else {
	$src_copy = $COPY_COMMAND{$st};
	$src_copy = "($src_copy LIMIT 10)";
	$pfx .= ' *';
  }

  print(STDERR "$pfx  (querying)\r");
  $dst_psql_pipe->print("COPY $st FROM STDIN;\n");
  $src_psql_w->print("COPY $src_copy TO STDOUT;\n");
  $src_psql_w->print("\\echo $TERM_STRING\n");
  my $nrows = 0;
  while (my $line = <$src_psql_r>) {
	if ($line =~ m/^ERROR:/) {
	  die("Oh, man, are you in trouble.\n$line\n");
	}
	if ($line =~ m/^$TERM_STRING/) {
	  $dst_psql_pipe->print("\\.\n");
	  last;
	}
	$dst_psql_pipe->print($line);
	$nrows++;
	printf("$pfx %15s\r","$nrows rows") if (-t 1 and $nrows % $VERBOSE_FREQ == 0);
  }
  printf("$pfx %15s (%d s)\n",
		 "$nrows rows",tv_interval($table_start));
}
$src_psql_w->print("\\q\n");
print(STDERR "waiting for src psql pipe process to die [pid=$src_psql_pid]\n");
waitpid($src_psql_pid,0);
print(STDERR "# src psql process finished\n");

#restore_subset( $dst_psql_pipe, $dump_fn, [grep { not m/\s(?:$phase1_re)\s/ } @toc] );

$dst_psql_pipe->close();

# !! comment, search_path, analyze

print(STDERR "# $0\n",
	  '# ended: ', strftime("%F %T %Z",localtime()),
	  ' (', sprintf("%.1f",tv_interval($all_start)/60/60), " h elapsed)\n");

exit(0);



## ######################################################################
## INTERNALS

sub get_schema_dump($$) {
  my ($db,$fn) = @_;
  my @cmd = ('pg_dump', '-Fc', '-s', '-f', $fn, $db);
  system(@cmd)
	&& die("@cmd: $!\n");
}

sub get_dump_toc($) {
  my $fn = shift;
  my $io = new IO::Pipe;
  my @cmd = ('pg_restore', '-l', $fn);
  $io->reader(@cmd)
	|| die("@cmd: $!\n");
  return grep { not /^;/ } <$io>;
}

sub restore_subset($$$) {
  my ($dst_psql_pipe,$dump_fn,$toc_aref) = @_;
  my $toc_fn = "$tmp_dir/toc";

  my $toc_fh = new IO::File;
  $toc_fh->open(">$toc_fn")
	|| die("$0: file $toc_fn: $!\n");
  $toc_fh->print($_) for @$toc_aref;
  $toc_fh->close();

  my $restore_pipe = new IO::Pipe;
  my @restore_cmd = ('pg_restore', '-Fc', '-L', $toc_fn, $dump_fn);
  $restore_pipe->reader(@restore_cmd)
	|| die("$0: commmand @restore_cmd: $!\n");
  $dst_psql_pipe->print($_) while <$restore_pipe>;
  $restore_pipe->close();
}

sub trivial_origin_join($) {
  my $st = shift;
  "SELECT T.* FROM ONLY $st T JOIN unison.porigin O on T.origin_id=O.origin_id and O.is_public=TRUE"
}
sub trivial_params_join($) {
  my $st = shift;
  "SELECT T.* FROM ONLY $st T JOIN unison.params P on T.params_id=P.params_id and P.is_public=TRUE"
}


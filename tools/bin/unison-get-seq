#!/usr/bin/env perl
# get-seq -- output selected sequences from Unison in fasta format
# $Id: get-seq,v 1.9 2004/05/04 05:10:34 rkh Exp $

use warnings;
use strict;
use Unison;
use Getopt::Long qw(:config gnu_getopt);


my %opts = 
  (
   'best-alias' => 0,
   'best-annotation' => 0,
   'all-aliases' => 0,
   'pro_id' => undef,
   'verbose' => 0,
   'pset_id' => undef
  );
GetOptions( \%opts,
			'best-alias|best-oa|b+',
			'best-annotation|best-oad|B+',
			'all-aliases|a+',
			'pro_id|proid|P=s@',
			'verbose|v+',
			'pset_id|S=i',
		  )
  || die("$0: you got usage issues, homey\n");

my $u = new Unison();
die( "! couldn't open a connection to unison\n" ) unless $u;

if (defined $opts{pset_id} and (defined $opts{pro_id} or @ARGV)) {
  die("$0: cannot specify pset_id with other sequence selection options\n");
}

if (defined $opts{pro_id}) {
  @{$opts{pro_id}} = map {split(/,/,$_)} @{$opts{pro_id}};
  unshift(@ARGV, SPDI_lookup('PRO',@{$opts{pro_id}}));
} elsif (defined $opts{pset_id}) {
  my @Q = map {@$_} @{$u->selectall_arrayref("select pseq_id from pseqset where pset_id=$opts{pset_id}")};
  unshift(@ARGV, @Q);
  printf(STDERR "# %d sequence ids in pset_id=%d\n", $#Q+1, $opts{pset_id});
}


if (@ARGV) {
  while( my $r = shift ) {
	process1($_) for eval "$r";
  }
} else {
  while (my $id=<>)	{
	chomp $id;
	process1($id) }
}

exit(0);

############################################################################

sub process1 {
  my $pseq_id = shift;
  my $seq = get1($pseq_id);
  if (not defined $seq) {
	warn("Unison:$pseq_id not found\n"); return;
  }
  print $seq;
}

sub get1 {
  my $pseq_id = shift;
  my @descr;
  my $rv;
  my $seq = $u->get_sequence_by_pseq_id($pseq_id);

  if (not defined $seq)
	{ warn("! pseq $pseq_id doesn't exist\n"); return; }

  if ($opts{'best-alias'})
	{ (@descr) = $u->best_alias($pseq_id,1) }
  elsif ($opts{'best-annotation'})
	{ (@descr) = $u->best_annotation($pseq_id,1) }
  elsif ($opts{'all-aliases'})
	{ (@descr) = $u->pseq_get_aliases($pseq_id) }

  @descr = () unless @descr;

  $rv = join(' ',">Unison:$pseq_id",@descr) . "\n";
  while( length($seq) )
	{ $rv .= substr($seq,0,60,'') . "\n"; }

  print(STDERR "# $pseq_id (", $descr[0]||'<no description>', ")\n") if $opts{verbose};
  return $rv;
}



sub SPDI_lookup {
  my $pfx = shift;
  return map {SPDI_lookup1($pfx,$_)} @_;
}

sub SPDI_lookup1 {
  my ($pfx,$id) = @_;
  my $sth = $u->prepare_cached(q/select pseq_id from palias where alias=? and
 								porigin_id=porigin_id_lookup('SPDI')/);
  $sth->execute("$pfx$id");
  my $rv = $sth->fetchrow_array;
  $sth->finish();
  return $rv;
}





=pod

=head1 NAME

get-seq -- retrieve sequences from Unison

S<$Id: get-seq,v 1.9 2004/05/04 05:10:34 rkh Exp $>

=head1 SYNOPSIS

 get-seq [-a|-A|-D] [pseq_id ...]

=head1 OPTIONS

=item B<--alpha> level, B<--Arpha> level, B<-a> level

=head1 DESCRIPTION

B<get-seq> writes selected sequences from Unison in fasta format to
STDOUT, optionally with aliases or annotations.

=cut
